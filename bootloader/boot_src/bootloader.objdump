
bootloader.elf:     file format elf32-littlenios2
bootloader.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x004001bc

Program Header:
    LOAD off    0x00001000 vaddr 0x00400000 paddr 0x00400000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00400020 paddr 0x00400020 align 2**12
         filesz 0x00002b18 memsz 0x00002b18 flags r-x
    LOAD off    0x00003b38 vaddr 0x00402b38 paddr 0x00404318 align 2**12
         filesz 0x000017e0 memsz 0x000017e0 flags rw-
    LOAD off    0x00005af8 vaddr 0x00405af8 paddr 0x00405af8 align 2**12
         filesz 0x00000000 memsz 0x00000118 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00400000  00400000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000019c  00400020  00400020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0000293c  004001bc  004001bc  000011bc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000040  00402af8  00402af8  00003af8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000017e0  00402b38  00404318  00003b38  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000118  00405af8  00405af8  00005af8  2**2
                  ALLOC, SMALL_DATA
  6 .constants    00000000  00002000  00002000  00005318  2**0
                  CONTENTS
  7 .onchip_memory2_0 00000000  00405c10  00405c10  00005318  2**0
                  CONTENTS
  8 .sdram        00000000  02000000  02000000  00005318  2**0
                  CONTENTS
  9 .flash_tristate_controller_0 00000000  03000000  03000000  00005318  2**0
                  CONTENTS
 10 .comment      00000023  00000000  00000000  00005318  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 000004d0  00000000  00000000  00005340  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   0000659b  00000000  00000000  00005810  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 0000257f  00000000  00000000  0000bdab  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0000252f  00000000  00000000  0000e32a  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00000b50  00000000  00000000  0001085c  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    000018f7  00000000  00000000  000113ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    000006d9  00000000  00000000  00012ca3  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_alt_sim_info 00000060  00000000  00000000  0001337c  2**2
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_ranges 000000d0  00000000  00000000  000133e0  2**3
                  CONTENTS, READONLY, DEBUGGING
 20 .thread_model 00000003  00000000  00000000  000150ed  2**0
                  CONTENTS, READONLY
 21 .cpu          00000005  00000000  00000000  000150f0  2**0
                  CONTENTS, READONLY
 22 .qsys         00000001  00000000  00000000  000150f5  2**0
                  CONTENTS, READONLY
 23 .simulation_enabled 00000001  00000000  00000000  000150f6  2**0
                  CONTENTS, READONLY
 24 .stderr_dev   00000004  00000000  00000000  000150f7  2**0
                  CONTENTS, READONLY
 25 .stdin_dev    00000004  00000000  00000000  000150fb  2**0
                  CONTENTS, READONLY
 26 .stdout_dev   00000004  00000000  00000000  000150ff  2**0
                  CONTENTS, READONLY
 27 .sopc_system_name 00000018  00000000  00000000  00015103  2**0
                  CONTENTS, READONLY
 28 .quartus_project_dir 00000053  00000000  00000000  0001511b  2**0
                  CONTENTS, READONLY
 29 .sopcinfo     0008f3d9  00000000  00000000  0001516e  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00400000 l    d  .entry	00000000 .entry
00400020 l    d  .exceptions	00000000 .exceptions
004001bc l    d  .text	00000000 .text
00402af8 l    d  .rodata	00000000 .rodata
00402b38 l    d  .rwdata	00000000 .rwdata
00405af8 l    d  .bss	00000000 .bss
00002000 l    d  .constants	00000000 .constants
00405c10 l    d  .onchip_memory2_0	00000000 .onchip_memory2_0
02000000 l    d  .sdram	00000000 .sdram
03000000 l    d  .flash_tristate_controller_0	00000000 .flash_tristate_controller_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../boot_bsp//obj/HAL/src/crt0.o
00400204 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
00400094 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 advanced_boot_copier.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 impure.c
00402b38 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_exit.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_load.c
00400aa8 l     F .text	00000064 alt_load_section
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00400bbc l     F .text	00000038 alt_dev_reg
00402f5c l     O .rwdata	00001060 jtag_uart_0
00403fbc l     O .rwdata	000000c4 debug_uart
00404080 l     O .rwdata	000000c4 uart_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
00400eec l     F .text	00000204 altera_avalon_jtag_uart_irq
004010f0 l     F .text	000000a8 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
00401710 l     F .text	00000074 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
004019c4 l     F .text	00000098 altera_avalon_uart_irq
00401a5c l     F .text	000000e0 altera_avalon_uart_rxirq
00401b3c l     F .text	00000144 altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
00401cd4 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
00401f00 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dev.c
00402394 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
004023c0 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
004029cc l     F .text	0000006c udivmodsi4
00400208 g     F .text	0000008c alt_main
00405b10 g     O .bss	00000100 alt_irq
00404318 g       *ABS*	00000000 __flash_rwdata_start
00000000  w      *UND*	00000000 __errno
00400000 g     F .entry	0000001c __reset
00400020 g       *ABS*	00000000 __flash_exceptions_start
00405b0c g     O .bss	00000004 errno
0040c2ec g       *ABS*	00000000 _gp
00400b8c g     F .text	00000030 usleep
03000000 g       *ABS*	00000000 __alt_mem_flash_tristate_controller_0
0040416c g     O .rwdata	00000180 alt_fd_list
00400294 g     F .text	00000064 JumpFromBootCopier
00400734 g     F .text	00000138 memcpy
004012ec g     F .text	0000020c altera_avalon_jtag_uart_read
00400000 g       *ABS*	00000000 __alt_mem_onchip_memory2_0
00402ae8 g     F .text	00000008 .hidden __udivsi3
004024b4 g     F .text	0000008c alt_icache_flush
00002000 g       *ABS*	00000000 __alt_mem_constants
00404304 g     O .rwdata	00000004 alt_max_fd
004042ec g     O .rwdata	00000004 _global_impure_ptr
00405c10 g       *ABS*	00000000 __bss_end
00402720 g     F .text	000000f0 alt_iic_isr_register
004028a8 g     F .text	00000104 alt_tick
00405af8 g     O .bss	00000004 flash_image_ptr_1
0040191c g     F .text	000000a8 altera_avalon_uart_init
004026d4 g     F .text	0000004c alt_ic_irq_enabled
00402810 g     F .text	00000098 alt_alarm_stop
004002f8 g     F .text	00000044 CopyFromFlash
00405b00 g     O .bss	00000004 alt_irq_active
004000ec g     F .exceptions	000000d0 alt_irq_handler
00404144 g     O .rwdata	00000028 alt_dev_null
00400540 g     F .text	000000a0 ValidateFlashImage
00400a00 g     F .text	00000044 alt_dcache_flush_all
00404318 g       *ABS*	00000000 __ram_rwdata_end
004042fc g     O .rwdata	00000008 alt_dev_list
00402b38 g       *ABS*	00000000 __ram_rodata_end
00402af0 g     F .text	00000008 .hidden __umodsi3
00405c10 g       *ABS*	00000000 end
00401f50 g     F .text	000001ac altera_avalon_uart_write
00400e28 g     F .text	000000c4 altera_avalon_jtag_uart_init
00500000 g       *ABS*	00000000 __alt_stack_pointer
00401784 g     F .text	00000088 alt_avalon_timer_sc_init
0040186c g     F .text	00000060 altera_avalon_uart_write_fd
004018cc g     F .text	00000050 altera_avalon_uart_close_fd
004014f8 g     F .text	00000218 altera_avalon_jtag_uart_write
0040086c g     F .text	00000194 __call_exitprocs
004001bc g     F .text	0000004c _start
00405b04 g     O .bss	00000004 _alt_tick_rate
00405b08 g     O .bss	00000004 _alt_nticks
00400c28 g     F .text	0000009c alt_sys_init
00401198 g     F .text	00000068 altera_avalon_jtag_uart_close
00402b38 g       *ABS*	00000000 __ram_rwdata_start
00402af8 g       *ABS*	00000000 __ram_rodata_start
0040033c g     F .text	0000012c LoadFlashImage
00400cc4 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
0040223c g     F .text	00000158 alt_busy_sleep
00400d84 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
00405c10 g       *ABS*	00000000 __alt_stack_base
00400dd4 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
00400468 g     F .text	000000d8 PickFlashImage
00402410 g     F .text	000000a4 alt_dev_llist_insert
00405af8 g       *ABS*	00000000 __bss_start
00400208  w    F .text	0000008c main
00400d24 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
00404308 g     O .rwdata	00000004 alt_errno
00402a38 g     F .text	00000054 .hidden __divsi3
00402af8 g       *ABS*	00000000 __flash_rodata_start
00400bf4 g     F .text	00000034 alt_irq_init
004042f0 g     O .rwdata	00000004 _impure_ptr
00400020 g       .exceptions	00000000 alt_irq_entry
004042f4 g     O .rwdata	00000008 alt_fs_list
00405afc g     O .bss	00000004 flash_image_ptr_2
00400020 g       *ABS*	00000000 __ram_exceptions_start
00402540 g     F .text	00000050 alt_ic_isr_register
00404318 g       *ABS*	00000000 _edata
0040180c g     F .text	00000060 altera_avalon_uart_read_fd
00405c10 g       *ABS*	00000000 _end
004001bc g       *ABS*	00000000 __ram_exceptions_end
00401200 g     F .text	000000ec altera_avalon_jtag_uart_ioctl
00402630 g     F .text	000000a4 alt_ic_irq_disable
004029ac g     F .text	00000020 altera_nios2_qsys_irq_init
004006fc g     F .text	00000038 exit
00402a8c g     F .text	0000005c .hidden __modsi3
00500000 g       *ABS*	00000000 __alt_data_end
00400020 g     F .exceptions	00000000 alt_exception
02000000 g       *ABS*	00000000 __alt_mem_sdram
004005e0 g     F .text	0000011c FlashCalcCRC32
00401c80 g     F .text	00000054 altera_avalon_uart_close
00400a44 g     F .text	00000034 _exit
004020fc g     F .text	00000140 alt_alarm_start
00400a78 g     F .text	00000030 alt_icache_flush_all
0040430c g     O .rwdata	00000004 alt_priority_mask
00402590 g     F .text	000000a0 alt_ic_irq_enable
00401d24 g     F .text	000001dc altera_avalon_uart_read
00404310 g     O .rwdata	00000008 alt_alarm_list
00400b0c g     F .text	00000080 alt_load
00000000  w      *UND*	00000000 free



Disassembly of section .entry:

00400000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
  400000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
  400004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
  400008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
  40000c:	00bffd16 	blt	zero,r2,400004 <__alt_mem_flash_tristate_controller_0+0xfd400004>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  400010:	00401034 	movhi	at,64
    ori r1, r1, %lo(_start)
  400014:	08406f14 	ori	at,at,444
    jmp r1
  400018:	0800683a 	jmp	at
  40001c:	00000000 	call	0 <__alt_mem_constants-0x2000>

Disassembly of section .exceptions:

00400020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
  400020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
  400024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
  400028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
  40002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
  400030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
  400034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
  400038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
  40003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
  400040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
  400044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
  400048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
  40004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
  400050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
  400054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
  400058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
  40005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
  400060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
  400064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
  400068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
  40006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  400070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
  400074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
  400078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
  40007c:	10000326 	beq	r2,zero,40008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
  400080:	20000226 	beq	r4,zero,40008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
  400084:	04000ec0 	call	4000ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
  400088:	00000306 	br	400098 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
  40008c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
  400090:	e8bfff17 	ldw	r2,-4(ea)

00400094 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
  400094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
  400098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
  40009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
  4000a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
  4000a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
  4000a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
  4000ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
  4000b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
  4000b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
  4000b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
  4000bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
  4000c0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
  4000c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
  4000c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
  4000cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
  4000d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
  4000d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
  4000d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
  4000dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
  4000e0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
  4000e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
  4000e8:	ef80083a 	eret

004000ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  4000ec:	defff904 	addi	sp,sp,-28
  4000f0:	dfc00615 	stw	ra,24(sp)
  4000f4:	df000515 	stw	fp,20(sp)
  4000f8:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
  4000fc:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  400100:	0005313a 	rdctl	r2,ipending
  400104:	e0bffe15 	stw	r2,-8(fp)

  return active;
  400108:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
  40010c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
  400110:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
  400114:	00800044 	movi	r2,1
  400118:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  40011c:	e0fffb17 	ldw	r3,-20(fp)
  400120:	e0bffc17 	ldw	r2,-16(fp)
  400124:	1884703a 	and	r2,r3,r2
  400128:	10001426 	beq	r2,zero,40017c <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  40012c:	00801034 	movhi	r2,64
  400130:	1096c404 	addi	r2,r2,23312
  400134:	e0fffd17 	ldw	r3,-12(fp)
  400138:	180690fa 	slli	r3,r3,3
  40013c:	10c5883a 	add	r2,r2,r3
  400140:	10c00017 	ldw	r3,0(r2)
  400144:	00801034 	movhi	r2,64
  400148:	1096c404 	addi	r2,r2,23312
  40014c:	e13ffd17 	ldw	r4,-12(fp)
  400150:	200890fa 	slli	r4,r4,3
  400154:	21000104 	addi	r4,r4,4
  400158:	1105883a 	add	r2,r2,r4
  40015c:	10800017 	ldw	r2,0(r2)
  400160:	1009883a 	mov	r4,r2
  400164:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
  400168:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  40016c:	0005313a 	rdctl	r2,ipending
  400170:	e0bfff15 	stw	r2,-4(fp)

  return active;
  400174:	e0bfff17 	ldw	r2,-4(fp)
  400178:	00000706 	br	400198 <alt_irq_handler+0xac>
      }
      mask <<= 1;
  40017c:	e0bffc17 	ldw	r2,-16(fp)
  400180:	1085883a 	add	r2,r2,r2
  400184:	e0bffc15 	stw	r2,-16(fp)
      i++;
  400188:	e0bffd17 	ldw	r2,-12(fp)
  40018c:	10800044 	addi	r2,r2,1
  400190:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
  400194:	003fe106 	br	40011c <__alt_mem_flash_tristate_controller_0+0xfd40011c>

    active = alt_irq_pending ();
  400198:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
  40019c:	e0bffb17 	ldw	r2,-20(fp)
  4001a0:	103fdb1e 	bne	r2,zero,400110 <__alt_mem_flash_tristate_controller_0+0xfd400110>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
  4001a4:	0001883a 	nop
}
  4001a8:	e037883a 	mov	sp,fp
  4001ac:	dfc00117 	ldw	ra,4(sp)
  4001b0:	df000017 	ldw	fp,0(sp)
  4001b4:	dec00204 	addi	sp,sp,8
  4001b8:	f800283a 	ret

Disassembly of section .text:

004001bc <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
  4001bc:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
  4001c0:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
  4001c4:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
  4001c8:	00bffd16 	blt	zero,r2,4001c0 <__alt_mem_flash_tristate_controller_0+0xfd4001c0>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  4001cc:	06c01434 	movhi	sp,80
    ori sp, sp, %lo(__alt_stack_pointer)
  4001d0:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
  4001d4:	06801034 	movhi	gp,64
    ori gp, gp, %lo(_gp)
  4001d8:	d6b0bb14 	ori	gp,gp,49900
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  4001dc:	00801034 	movhi	r2,64
    ori r2, r2, %lo(__bss_start)
  4001e0:	1096be14 	ori	r2,r2,23288

    movhi r3, %hi(__bss_end)
  4001e4:	00c01034 	movhi	r3,64
    ori r3, r3, %lo(__bss_end)
  4001e8:	18d70414 	ori	r3,r3,23568

    beq r2, r3, 1f
  4001ec:	10c00326 	beq	r2,r3,4001fc <_start+0x40>

0:
    stw zero, (r2)
  4001f0:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  4001f4:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  4001f8:	10fffd36 	bltu	r2,r3,4001f0 <__alt_mem_flash_tristate_controller_0+0xfd4001f0>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
  4001fc:	0400b0c0 	call	400b0c <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  400200:	04002080 	call	400208 <alt_main>

00400204 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  400204:	003fff06 	br	400204 <__alt_mem_flash_tristate_controller_0+0xfd400204>

00400208 <alt_main>:
*  code size may be a consideration, this method allows us to keep the 
*  memory requirements small.
*
*****************************************************************************/
int alt_main(void)
{
  400208:	defffb04 	addi	sp,sp,-20
  40020c:	dfc00415 	stw	ra,16(sp)
  400210:	df000315 	stw	fp,12(sp)
  400214:	df000304 	addi	fp,sp,12
   * Define the local variables used by this function.
   */
  int boot_image;
  alt_u32 entry_point;
  
  flash_image_ptr_1 = (void*)BOOT_IMAGE_1_ADDR;
  400218:	0080c934 	movhi	r2,804
  40021c:	d0a60315 	stw	r2,-26612(gp)
  flash_image_ptr_2 = (void*)BOOT_IMAGE_2_ADDR;
  400220:	0080d134 	movhi	r2,836
  400224:	d0a60415 	stw	r2,-26608(gp)

  /*
   * In order to allow interrupts to occur while the boot copier executes we 
   * initialize the main irq handler.
   */
  alt_irq_init (ALT_IRQ_BASE);
  400228:	0009883a 	mov	r4,zero
  40022c:	0400bf40 	call	400bf4 <alt_irq_init>
  
  /*
   * Now we initialize the drivers that we require.
   */
  alt_sys_init();
  400230:	0400c280 	call	400c28 <alt_sys_init>
  /*
   * Pick a flash image to load.  The criteria for picking an image are 
   * discussed the text of the application note, and also in the code comments 
   * preceeding the function "PickFlashImage()" found in this file.
   */
  if( (boot_image = PickFlashImage()) ) 
  400234:	04004680 	call	400468 <PickFlashImage>
  400238:	e0bffd15 	stw	r2,-12(fp)
  40023c:	e0bffd17 	ldw	r2,-12(fp)
  400240:	10000d26 	beq	r2,zero,400278 <alt_main+0x70>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  400244:	0005303a 	rdctl	r2,status
  400248:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  40024c:	e0ffff17 	ldw	r3,-4(fp)
  400250:	00bfff84 	movi	r2,-2
  400254:	1884703a 	and	r2,r3,r2
  400258:	1001703a 	wrctl	status,r2
     * generated by running "nios2-elf-objdump.exe" with the -d option from a 
     * Nios II Command Shell.
     */
    alt_irq_disable_all ();
   
    entry_point = LoadFlashImage( boot_image );
  40025c:	e13ffd17 	ldw	r4,-12(fp)
  400260:	040033c0 	call	40033c <LoadFlashImage>
  400264:	e0bffe15 	stw	r2,-8(fp)
    {
      // Turn on an LED to indicate we are jumping to a valid image.
//      IOWR_ALTERA_AVALON_PIO_DATA(PERIPHERAL_SUBSYSTEM_LED_PIO_BASE, 0x2);

      // Jump to the entry point of the application
      JumpFromBootCopier((void(*)(void))(entry_point));
  400268:	e0bffe17 	ldw	r2,-8(fp)
  40026c:	1009883a 	mov	r4,r2
  400270:	04002940 	call	400294 <JumpFromBootCopier>
  400274:	00000506 	br	40028c <alt_main+0x84>

    // Turn on an LED to indicate we are resetting
//    IOWR_ALTERA_AVALON_PIO_DATA(PERIPHERAL_SUBSYSTEM_LED_PIO_BASE, 0x4);
    
    // Wait 5 seconds
    usleep(5000000);
  400278:	01001334 	movhi	r4,76
  40027c:	2112d004 	addi	r4,r4,19264
  400280:	0400b8c0 	call	400b8c <usleep>
      
    // Jump back to the reset address
    JumpFromBootCopier((void(*)(void))(NIOS2_RESET_ADDR));
  400284:	01001034 	movhi	r4,64
  400288:	04002940 	call	400294 <JumpFromBootCopier>
  }
  
  // We should never get here
  exit(0);
  40028c:	0009883a 	mov	r4,zero
  400290:	04006fc0 	call	4006fc <exit>

00400294 <JumpFromBootCopier>:
*  Purpose: This routine shuts down the boot copier and jumps somewhere else. 
*  The place to jump is passed in as a function pointer named "target".
*
*****************************************************************************/
void JumpFromBootCopier(void target(void))
{
  400294:	defffc04 	addi	sp,sp,-16
  400298:	dfc00315 	stw	ra,12(sp)
  40029c:	df000215 	stw	fp,8(sp)
  4002a0:	df000204 	addi	fp,sp,8
  4002a4:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  4002a8:	0005303a 	rdctl	r2,status
  4002ac:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  4002b0:	e0fffe17 	ldw	r3,-8(fp)
  4002b4:	00bfff84 	movi	r2,-2
  4002b8:	1884703a 	and	r2,r3,r2
  4002bc:	1001703a 	wrctl	status,r2
   * equivalent to reset.  If we disable interrupts, and flush the caches, 
   * then the program we jump to should receive the cpu just as it would 
   * coming out of a hardware reset.
   */
  alt_irq_disable_all ();
  alt_dcache_flush_all ();
  4002c0:	0400a000 	call	400a00 <alt_dcache_flush_all>
  alt_icache_flush_all ();
  4002c4:	0400a780 	call	400a78 <alt_icache_flush_all>
  
  /*
   * The cpu state is as close to reset as we can get it, so we jump to the new
   * application.
   */
  target();
  4002c8:	e0bfff17 	ldw	r2,-4(fp)
  4002cc:	103ee83a 	callr	r2
   
  // Turn on an LED to indicate we are resetting
//  IOWR_ALTERA_AVALON_PIO_DATA(PERIPHERAL_SUBSYSTEM_LED_PIO_BASE, 0x4);

  // Wait 5 seconds
  usleep(5000000);
  4002d0:	01001334 	movhi	r4,76
  4002d4:	2112d004 	addi	r4,r4,19264
  4002d8:	0400b8c0 	call	400b8c <usleep>

  // Jump back to the reset address
  JumpFromBootCopier((void(*)(void))(NIOS2_RESET_ADDR));
  4002dc:	01001034 	movhi	r4,64
  4002e0:	04002940 	call	400294 <JumpFromBootCopier>
}
  4002e4:	e037883a 	mov	sp,fp
  4002e8:	dfc00117 	ldw	ra,4(sp)
  4002ec:	df000017 	ldw	fp,0(sp)
  4002f0:	dec00204 	addi	sp,sp,8
  4002f4:	f800283a 	ret

004002f8 <CopyFromFlash>:
*  defined by FLASH_TYPE.  EPCS devices cant simply be read from using
*  memcpy().
*
*****************************************************************************/
void* CopyFromFlash( void * dest, const void * src, size_t num )
{
  4002f8:	defffb04 	addi	sp,sp,-20
  4002fc:	dfc00415 	stw	ra,16(sp)
  400300:	df000315 	stw	fp,12(sp)
  400304:	df000304 	addi	fp,sp,12
  400308:	e13ffd15 	stw	r4,-12(fp)
  40030c:	e17ffe15 	stw	r5,-8(fp)
  400310:	e1bfff15 	stw	r6,-4(fp)
# if( FLASH_TYPE == CFI )

    memcpy( dest, src, num );
  400314:	e13ffd17 	ldw	r4,-12(fp)
  400318:	e17ffe17 	ldw	r5,-8(fp)
  40031c:	e1bfff17 	ldw	r6,-4(fp)
  400320:	04007340 	call	400734 <memcpy>
                      (alt_u8*)dest,
                      (int)num );

# endif //FLASH_TYPE

  return (dest);
  400324:	e0bffd17 	ldw	r2,-12(fp)
}
  400328:	e037883a 	mov	sp,fp
  40032c:	dfc00117 	ldw	ra,4(sp)
  400330:	df000017 	ldw	fp,0(sp)
  400334:	dec00204 	addi	sp,sp,8
  400338:	f800283a 	ret

0040033c <LoadFlashImage>:
*  The input operand, "image" is expected to be the image selector indicating
*  which flash image, 1 or 2, should be loaded.
*
*****************************************************************************/
alt_u32 LoadFlashImage ( int image )
{
  40033c:	defffa04 	addi	sp,sp,-24
  400340:	dfc00515 	stw	ra,20(sp)
  400344:	df000415 	stw	fp,16(sp)
  400348:	df000404 	addi	fp,sp,16
  40034c:	e13fff15 	stw	r4,-4(fp)
  
  /*
   * Load the image pointer based on the value of "image"
   * The boot image header is 32 bytes long, so we add an offset of 32.
   */
  if( image == 1 )
  400350:	e0bfff17 	ldw	r2,-4(fp)
  400354:	10800058 	cmpnei	r2,r2,1
  400358:	1000041e 	bne	r2,zero,40036c <LoadFlashImage+0x30>
  {
    next_flash_byte = (alt_u8 *)flash_image_ptr_1 + 32;
  40035c:	d0a60317 	ldw	r2,-26612(gp)
  400360:	10800804 	addi	r2,r2,32
  400364:	e0bffc15 	stw	r2,-16(fp)
  400368:	00000306 	br	400378 <LoadFlashImage+0x3c>
  }
  else
  {
    next_flash_byte = (alt_u8 *)flash_image_ptr_2 + 32;
  40036c:	d0a60417 	ldw	r2,-26608(gp)
  400370:	10800804 	addi	r2,r2,32
  400374:	e0bffc15 	stw	r2,-16(fp)
   * The "memcpy()" function works well to copy non-word-aligned data, and 
   * it is relativly small, so that's what we'll use.
   */
   
  // Get the first 4 bytes of the boot record, which should be a length record
  CopyFromFlash( (void*)(&length), (void*)(next_flash_byte), (size_t)(4) );
  400378:	e0bffd04 	addi	r2,fp,-12
  40037c:	1009883a 	mov	r4,r2
  400380:	e17ffc17 	ldw	r5,-16(fp)
  400384:	01800104 	movi	r6,4
  400388:	04002f80 	call	4002f8 <CopyFromFlash>
  next_flash_byte += 4;
  40038c:	e0bffc17 	ldw	r2,-16(fp)
  400390:	10800104 	addi	r2,r2,4
  400394:	e0bffc15 	stw	r2,-16(fp)
  
  // Now loop until we get jump record, or a halt recotd
  while( (length != 0) && (length != 0xffffffff) )
  400398:	00001b06 	br	400408 <LoadFlashImage+0xcc>
  {
    // Get the next 4 bytes of the boot record, which should be an address 
    // record
    CopyFromFlash( (void*)(&address), (void*)(next_flash_byte), (size_t)(4) );
  40039c:	e0bffe04 	addi	r2,fp,-8
  4003a0:	1009883a 	mov	r4,r2
  4003a4:	e17ffc17 	ldw	r5,-16(fp)
  4003a8:	01800104 	movi	r6,4
  4003ac:	04002f80 	call	4002f8 <CopyFromFlash>
    next_flash_byte += 4;
  4003b0:	e0bffc17 	ldw	r2,-16(fp)
  4003b4:	10800104 	addi	r2,r2,4
  4003b8:	e0bffc15 	stw	r2,-16(fp)
    
    // Copy the next "length" bytes to "address"
    CopyFromFlash( (void*)(address), (void*)(next_flash_byte), (size_t)(length) );
  4003bc:	e0bffe17 	ldw	r2,-8(fp)
  4003c0:	1007883a 	mov	r3,r2
  4003c4:	e0bffd17 	ldw	r2,-12(fp)
  4003c8:	1809883a 	mov	r4,r3
  4003cc:	e17ffc17 	ldw	r5,-16(fp)
  4003d0:	100d883a 	mov	r6,r2
  4003d4:	04002f80 	call	4002f8 <CopyFromFlash>
    next_flash_byte += length;
  4003d8:	e0bffd17 	ldw	r2,-12(fp)
  4003dc:	e0fffc17 	ldw	r3,-16(fp)
  4003e0:	1885883a 	add	r2,r3,r2
  4003e4:	e0bffc15 	stw	r2,-16(fp)
    
    // Get the next 4 bytes of the boot record, which now should be another 
    // length record
    CopyFromFlash( (void*)(&length), (void*)(next_flash_byte), (size_t)(4) );
  4003e8:	e0bffd04 	addi	r2,fp,-12
  4003ec:	1009883a 	mov	r4,r2
  4003f0:	e17ffc17 	ldw	r5,-16(fp)
  4003f4:	01800104 	movi	r6,4
  4003f8:	04002f80 	call	4002f8 <CopyFromFlash>
    next_flash_byte += 4;
  4003fc:	e0bffc17 	ldw	r2,-16(fp)
  400400:	10800104 	addi	r2,r2,4
  400404:	e0bffc15 	stw	r2,-16(fp)
  // Get the first 4 bytes of the boot record, which should be a length record
  CopyFromFlash( (void*)(&length), (void*)(next_flash_byte), (size_t)(4) );
  next_flash_byte += 4;
  
  // Now loop until we get jump record, or a halt recotd
  while( (length != 0) && (length != 0xffffffff) )
  400408:	e0bffd17 	ldw	r2,-12(fp)
  40040c:	10000326 	beq	r2,zero,40041c <LoadFlashImage+0xe0>
  400410:	e0bffd17 	ldw	r2,-12(fp)
  400414:	10bfffd8 	cmpnei	r2,r2,-1
  400418:	103fe01e 	bne	r2,zero,40039c <__alt_mem_flash_tristate_controller_0+0xfd40039c>
    next_flash_byte += 4;
  }
  
  // "length" was read as either 0x0 or 0xffffffff, which means we are done 
  // copying.
  if( length == 0xffffffff )
  40041c:	e0bffd17 	ldw	r2,-12(fp)
  400420:	10bfffd8 	cmpnei	r2,r2,-1
  400424:	1000021e 	bne	r2,zero,400430 <LoadFlashImage+0xf4>
  {
    // We read a HALT record, so return a -1
    return -1;
  400428:	00bfffc4 	movi	r2,-1
  40042c:	00000906 	br	400454 <LoadFlashImage+0x118>
  }
  else // length == 0x0
  {
    // We got a jump record, so read the next 4 bytes for the entry address
    CopyFromFlash( (void*)(&address), (void*)(next_flash_byte), (size_t)(4) );
  400430:	e0bffe04 	addi	r2,fp,-8
  400434:	1009883a 	mov	r4,r2
  400438:	e17ffc17 	ldw	r5,-16(fp)
  40043c:	01800104 	movi	r6,4
  400440:	04002f80 	call	4002f8 <CopyFromFlash>
    next_flash_byte += 4;
  400444:	e0bffc17 	ldw	r2,-16(fp)
  400448:	10800104 	addi	r2,r2,4
  40044c:	e0bffc15 	stw	r2,-16(fp)
    
    // Return the entry point address
    return address;
  400450:	e0bffe17 	ldw	r2,-8(fp)
  }
}
  400454:	e037883a 	mov	sp,fp
  400458:	dfc00117 	ldw	ra,4(sp)
  40045c:	df000017 	ldw	fp,0(sp)
  400460:	dec00204 	addi	sp,sp,8
  400464:	f800283a 	ret

00400468 <PickFlashImage>:
*          C - If both time stamp values are equal, the we choose image #2
*    3 - If neither image is valid, we return 0
*
*****************************************************************************/
int PickFlashImage(void)
{
  400468:	deffee04 	addi	sp,sp,-72
  40046c:	dfc01115 	stw	ra,68(sp)
  400470:	df001015 	stw	fp,64(sp)
  400474:	df001004 	addi	fp,sp,64
  // Make sure our flash header buffers are word-aligned
  my_flash_header_type header_buffer_1 __attribute__((aligned(4)));
  my_flash_header_type header_buffer_2 __attribute__((aligned(4)));
  
  // Start by validating image 1
  if( ValidateFlashImage((alt_u32 *)(flash_image_ptr_1)) )
  400478:	d0a60317 	ldw	r2,-26612(gp)
  40047c:	1009883a 	mov	r4,r2
  400480:	04005400 	call	400540 <ValidateFlashImage>
  400484:	10000826 	beq	r2,zero,4004a8 <PickFlashImage+0x40>
  {
    // Image 1 was not valid, so validate image 2
    if( ValidateFlashImage((alt_u32 *)(flash_image_ptr_2)) )
  400488:	d0a60417 	ldw	r2,-26608(gp)
  40048c:	1009883a 	mov	r4,r2
  400490:	04005400 	call	400540 <ValidateFlashImage>
  400494:	10000226 	beq	r2,zero,4004a0 <PickFlashImage+0x38>
    {
      // Image 2 is not valid, return 0
      return 0;
  400498:	0005883a 	mov	r2,zero
  40049c:	00002306 	br	40052c <PickFlashImage+0xc4>
    }
    else
    {
      // Image 2 is valid and image 1 is not, so choose 2
      return 2;
  4004a0:	00800084 	movi	r2,2
  4004a4:	00002106 	br	40052c <PickFlashImage+0xc4>
    }
  }
  else
  {
    // Image 1 is valid, check image 2
    if( ValidateFlashImage((alt_u32 *)(flash_image_ptr_2)) )
  4004a8:	d0a60417 	ldw	r2,-26608(gp)
  4004ac:	1009883a 	mov	r4,r2
  4004b0:	04005400 	call	400540 <ValidateFlashImage>
  4004b4:	10000226 	beq	r2,zero,4004c0 <PickFlashImage+0x58>
    {
      // Image 2 is not valid and image 1 is, so choose image 1
      return 1;
  4004b8:	00800044 	movi	r2,1
  4004bc:	00001b06 	br	40052c <PickFlashImage+0xc4>
       * Just like the load_flash subroutine above, we don't assume that the
       * flash images are word aligned, so we memcpy the boot image headers 
       * from flash, to our word aligned temporary header buffers.  
       */

        CopyFromFlash(&header_buffer_1, flash_image_ptr_1, 32);
  4004c0:	d0a60317 	ldw	r2,-26612(gp)
  4004c4:	e13ff004 	addi	r4,fp,-64
  4004c8:	100b883a 	mov	r5,r2
  4004cc:	01800804 	movi	r6,32
  4004d0:	04002f80 	call	4002f8 <CopyFromFlash>
        CopyFromFlash(&header_buffer_2, flash_image_ptr_2, 32);
  4004d4:	d0a60417 	ldw	r2,-26608(gp)
  4004d8:	e0fff804 	addi	r3,fp,-32
  4004dc:	1809883a 	mov	r4,r3
  4004e0:	100b883a 	mov	r5,r2
  4004e4:	01800804 	movi	r6,32
  4004e8:	04002f80 	call	4002f8 <CopyFromFlash>
      
      // First compare the versions
      if( header_buffer_1.version == header_buffer_2.version )
  4004ec:	e0fff117 	ldw	r3,-60(fp)
  4004f0:	e0bff917 	ldw	r2,-28(fp)
  4004f4:	1880071e 	bne	r3,r2,400514 <PickFlashImage+0xac>
      {
        // The versions are equal, so compare timestamps
        if( header_buffer_1.timestamp > header_buffer_2.timestamp )
  4004f8:	e0bff217 	ldw	r2,-56(fp)
  4004fc:	e0fffa17 	ldw	r3,-24(fp)
  400500:	1880022e 	bgeu	r3,r2,40050c <PickFlashImage+0xa4>
        {
          // Image 1 has a later timestamp
          return 1;
  400504:	00800044 	movi	r2,1
  400508:	00000806 	br	40052c <PickFlashImage+0xc4>
        }
        else
        {
          // Image 2 has a later timestamp, or the timestamps were equal
          return 2;
  40050c:	00800084 	movi	r2,2
  400510:	00000606 	br	40052c <PickFlashImage+0xc4>
        }
      }
      else
      {
        // The versions were not equal
        if( header_buffer_1.version > header_buffer_2.version )
  400514:	e0bff117 	ldw	r2,-60(fp)
  400518:	e0fff917 	ldw	r3,-28(fp)
  40051c:	1880022e 	bgeu	r3,r2,400528 <PickFlashImage+0xc0>
        {
          // Image 1 has a later version
          return 1;
  400520:	00800044 	movi	r2,1
  400524:	00000106 	br	40052c <PickFlashImage+0xc4>
        }
        else
        {
          // Image 2 has a later version
          return 2;
  400528:	00800084 	movi	r2,2
        }
      }
    }
  }
}
  40052c:	e037883a 	mov	sp,fp
  400530:	dfc00117 	ldw	ra,4(sp)
  400534:	df000017 	ldw	fp,0(sp)
  400538:	dec00204 	addi	sp,sp,8
  40053c:	f800283a 	ret

00400540 <ValidateFlashImage>:
*  in the case of EPCS, and create a medium-size buffer, who's size is 
*  adjustable by the user.
*
*****************************************************************************/
int ValidateFlashImage(void *image_ptr)
{
  400540:	defff404 	addi	sp,sp,-48
  400544:	dfc00b15 	stw	ra,44(sp)
  400548:	df000a15 	stw	fp,40(sp)
  40054c:	dc000915 	stw	r16,36(sp)
  400550:	df000a04 	addi	fp,sp,40
  400554:	e13ffe15 	stw	r4,-8(fp)
  
  /*
   * Again, we don't assume the image is word aligned, so we copy the header
   * from flash to a word aligned buffer.
   */
    CopyFromFlash(&temp_header, image_ptr, 32);
  400558:	e13ff604 	addi	r4,fp,-40
  40055c:	e17ffe17 	ldw	r5,-8(fp)
  400560:	01800804 	movi	r6,32
  400564:	04002f80 	call	4002f8 <CopyFromFlash>
  
  // Check the signature first
  if( temp_header.signature == 0xa5a5a5a5 )
  400568:	e0fff617 	ldw	r3,-40(fp)
  40056c:	00a969b4 	movhi	r2,42406
  400570:	10a96944 	addi	r2,r2,-23131
  400574:	1880131e 	bne	r3,r2,4005c4 <ValidateFlashImage+0x84>
  {
    // Signature is good, validate the header crc
    if( temp_header.header_crc != FlashCalcCRC32( (alt_u8*)image_ptr, 28) )
  400578:	e43ffd17 	ldw	r16,-12(fp)
  40057c:	e13ffe17 	ldw	r4,-8(fp)
  400580:	01400704 	movi	r5,28
  400584:	04005e00 	call	4005e0 <FlashCalcCRC32>
  400588:	80800226 	beq	r16,r2,400594 <ValidateFlashImage+0x54>
    {
      // Header crc is not valid
      return HEADER_CRC_INVALID; 
  40058c:	00800084 	movi	r2,2
  400590:	00000d06 	br	4005c8 <ValidateFlashImage+0x88>
     }
    else
    {
      // header crc is valid, now validate the data crc
      if ( temp_header.data_crc == FlashCalcCRC32( image_ptr + 32, temp_header.data_length) )
  400594:	e43ffa17 	ldw	r16,-24(fp)
  400598:	e0bffe17 	ldw	r2,-8(fp)
  40059c:	10800804 	addi	r2,r2,32
  4005a0:	e0fff917 	ldw	r3,-28(fp)
  4005a4:	1009883a 	mov	r4,r2
  4005a8:	180b883a 	mov	r5,r3
  4005ac:	04005e00 	call	4005e0 <FlashCalcCRC32>
  4005b0:	8080021e 	bne	r16,r2,4005bc <ValidateFlashImage+0x7c>
      {
        // data crc validates, the image is good
        return CRCS_VALID; 
  4005b4:	0005883a 	mov	r2,zero
  4005b8:	00000306 	br	4005c8 <ValidateFlashImage+0x88>
      }
      else
      {
        // data crc is not valid
        return DATA_CRC_INVALID; 
  4005bc:	008000c4 	movi	r2,3
  4005c0:	00000106 	br	4005c8 <ValidateFlashImage+0x88>
    }
  }
  else
  {
    // bad signature, return 1
    return SIGNATURE_INVALID;
  4005c4:	00800044 	movi	r2,1
  }
} 
  4005c8:	e6ffff04 	addi	sp,fp,-4
  4005cc:	dfc00217 	ldw	ra,8(sp)
  4005d0:	df000117 	ldw	fp,4(sp)
  4005d4:	dc000017 	ldw	r16,0(sp)
  4005d8:	dec00304 	addi	sp,sp,12
  4005dc:	f800283a 	ret

004005e0 <FlashCalcCRC32>:
*  flash.  The routine buffers flash contents locally in order
*  to support EPCS flash as well as CFI
*
*****************************************************************************/
alt_u32 FlashCalcCRC32(alt_u8 *flash_addr, int bytes)
{
  4005e0:	deffb704 	addi	sp,sp,-292
  4005e4:	dfc04815 	stw	ra,288(sp)
  4005e8:	df004715 	stw	fp,284(sp)
  4005ec:	df004704 	addi	fp,sp,284
  4005f0:	e13ffe15 	stw	r4,-8(fp)
  4005f4:	e17fff15 	stw	r5,-4(fp)
  alt_u32 crcval = 0xffffffff;
  4005f8:	00bfffc4 	movi	r2,-1
  4005fc:	e0bfb915 	stw	r2,-284(fp)
  int i, buf_index, copy_length;
  alt_u8 cval;
  char flash_buffer[FLASH_BUFFER_LENGTH];
  
  while(bytes != 0)
  400600:	00003606 	br	4006dc <FlashCalcCRC32+0xfc>
  {
    copy_length = (FLASH_BUFFER_LENGTH < bytes) ? FLASH_BUFFER_LENGTH : bytes;
  400604:	e0bfff17 	ldw	r2,-4(fp)
  400608:	10c04050 	cmplti	r3,r2,257
  40060c:	1800011e 	bne	r3,zero,400614 <FlashCalcCRC32+0x34>
  400610:	00804004 	movi	r2,256
  400614:	e0bfbc15 	stw	r2,-272(fp)
    CopyFromFlash(flash_buffer, flash_addr, copy_length);
  400618:	e0bfbc17 	ldw	r2,-272(fp)
  40061c:	e0ffbd44 	addi	r3,fp,-267
  400620:	1809883a 	mov	r4,r3
  400624:	e17ffe17 	ldw	r5,-8(fp)
  400628:	100d883a 	mov	r6,r2
  40062c:	04002f80 	call	4002f8 <CopyFromFlash>
    for(buf_index = 0; buf_index < copy_length; buf_index++ )
  400630:	e03fbb15 	stw	zero,-276(fp)
  400634:	00002306 	br	4006c4 <FlashCalcCRC32+0xe4>
    {
      cval = flash_buffer[buf_index];
  400638:	e0ffbd44 	addi	r3,fp,-267
  40063c:	e0bfbb17 	ldw	r2,-276(fp)
  400640:	1885883a 	add	r2,r3,r2
  400644:	10800003 	ldbu	r2,0(r2)
  400648:	e0bfbd05 	stb	r2,-268(fp)
      crcval ^= cval;
  40064c:	e0bfbd03 	ldbu	r2,-268(fp)
  400650:	e0ffb917 	ldw	r3,-284(fp)
  400654:	1884f03a 	xor	r2,r3,r2
  400658:	e0bfb915 	stw	r2,-284(fp)
      for (i = 8; i > 0; i-- )
  40065c:	00800204 	movi	r2,8
  400660:	e0bfba15 	stw	r2,-280(fp)
  400664:	00000f06 	br	4006a4 <FlashCalcCRC32+0xc4>
      {
        crcval = (crcval & 0x00000001) ? ((crcval >> 1) ^ 0xEDB88320) : (crcval >> 1);
  400668:	e0bfb917 	ldw	r2,-284(fp)
  40066c:	1080004c 	andi	r2,r2,1
  400670:	10000626 	beq	r2,zero,40068c <FlashCalcCRC32+0xac>
  400674:	e0bfb917 	ldw	r2,-284(fp)
  400678:	1006d07a 	srli	r3,r2,1
  40067c:	00bb6e74 	movhi	r2,60857
  400680:	10a0c804 	addi	r2,r2,-31968
  400684:	1884f03a 	xor	r2,r3,r2
  400688:	00000206 	br	400694 <FlashCalcCRC32+0xb4>
  40068c:	e0bfb917 	ldw	r2,-284(fp)
  400690:	1004d07a 	srli	r2,r2,1
  400694:	e0bfb915 	stw	r2,-284(fp)
    CopyFromFlash(flash_buffer, flash_addr, copy_length);
    for(buf_index = 0; buf_index < copy_length; buf_index++ )
    {
      cval = flash_buffer[buf_index];
      crcval ^= cval;
      for (i = 8; i > 0; i-- )
  400698:	e0bfba17 	ldw	r2,-280(fp)
  40069c:	10bfffc4 	addi	r2,r2,-1
  4006a0:	e0bfba15 	stw	r2,-280(fp)
  4006a4:	e0bfba17 	ldw	r2,-280(fp)
  4006a8:	00bfef16 	blt	zero,r2,400668 <__alt_mem_flash_tristate_controller_0+0xfd400668>
      {
        crcval = (crcval & 0x00000001) ? ((crcval >> 1) ^ 0xEDB88320) : (crcval >> 1);
      }
      bytes--;
  4006ac:	e0bfff17 	ldw	r2,-4(fp)
  4006b0:	10bfffc4 	addi	r2,r2,-1
  4006b4:	e0bfff15 	stw	r2,-4(fp)
  
  while(bytes != 0)
  {
    copy_length = (FLASH_BUFFER_LENGTH < bytes) ? FLASH_BUFFER_LENGTH : bytes;
    CopyFromFlash(flash_buffer, flash_addr, copy_length);
    for(buf_index = 0; buf_index < copy_length; buf_index++ )
  4006b8:	e0bfbb17 	ldw	r2,-276(fp)
  4006bc:	10800044 	addi	r2,r2,1
  4006c0:	e0bfbb15 	stw	r2,-276(fp)
  4006c4:	e0ffbb17 	ldw	r3,-276(fp)
  4006c8:	e0bfbc17 	ldw	r2,-272(fp)
  4006cc:	18bfda16 	blt	r3,r2,400638 <__alt_mem_flash_tristate_controller_0+0xfd400638>
      {
        crcval = (crcval & 0x00000001) ? ((crcval >> 1) ^ 0xEDB88320) : (crcval >> 1);
      }
      bytes--;
    }
    flash_addr += FLASH_BUFFER_LENGTH;
  4006d0:	e0bffe17 	ldw	r2,-8(fp)
  4006d4:	10804004 	addi	r2,r2,256
  4006d8:	e0bffe15 	stw	r2,-8(fp)
  alt_u32 crcval = 0xffffffff;
  int i, buf_index, copy_length;
  alt_u8 cval;
  char flash_buffer[FLASH_BUFFER_LENGTH];
  
  while(bytes != 0)
  4006dc:	e0bfff17 	ldw	r2,-4(fp)
  4006e0:	103fc81e 	bne	r2,zero,400604 <__alt_mem_flash_tristate_controller_0+0xfd400604>
      }
      bytes--;
    }
    flash_addr += FLASH_BUFFER_LENGTH;
  }
  return crcval;
  4006e4:	e0bfb917 	ldw	r2,-284(fp)
}
  4006e8:	e037883a 	mov	sp,fp
  4006ec:	dfc00117 	ldw	ra,4(sp)
  4006f0:	df000017 	ldw	fp,0(sp)
  4006f4:	dec00204 	addi	sp,sp,8
  4006f8:	f800283a 	ret

004006fc <exit>:
  4006fc:	defffe04 	addi	sp,sp,-8
  400700:	000b883a 	mov	r5,zero
  400704:	dc000015 	stw	r16,0(sp)
  400708:	dfc00115 	stw	ra,4(sp)
  40070c:	2021883a 	mov	r16,r4
  400710:	040086c0 	call	40086c <__call_exitprocs>
  400714:	00801034 	movhi	r2,64
  400718:	1090bb04 	addi	r2,r2,17132
  40071c:	11000017 	ldw	r4,0(r2)
  400720:	20800f17 	ldw	r2,60(r4)
  400724:	10000126 	beq	r2,zero,40072c <exit+0x30>
  400728:	103ee83a 	callr	r2
  40072c:	8009883a 	mov	r4,r16
  400730:	0400a440 	call	400a44 <_exit>

00400734 <memcpy>:
  400734:	deffff04 	addi	sp,sp,-4
  400738:	dc000015 	stw	r16,0(sp)
  40073c:	00c003c4 	movi	r3,15
  400740:	2005883a 	mov	r2,r4
  400744:	1980432e 	bgeu	r3,r6,400854 <memcpy+0x120>
  400748:	2146b03a 	or	r3,r4,r5
  40074c:	18c000cc 	andi	r3,r3,3
  400750:	1800421e 	bne	r3,zero,40085c <memcpy+0x128>
  400754:	343ffc04 	addi	r16,r6,-16
  400758:	8020d13a 	srli	r16,r16,4
  40075c:	28c00104 	addi	r3,r5,4
  400760:	23400104 	addi	r13,r4,4
  400764:	801e913a 	slli	r15,r16,4
  400768:	2b000204 	addi	r12,r5,8
  40076c:	22c00204 	addi	r11,r4,8
  400770:	7bc00504 	addi	r15,r15,20
  400774:	2a800304 	addi	r10,r5,12
  400778:	22400304 	addi	r9,r4,12
  40077c:	2bdf883a 	add	r15,r5,r15
  400780:	2811883a 	mov	r8,r5
  400784:	200f883a 	mov	r7,r4
  400788:	41000017 	ldw	r4,0(r8)
  40078c:	39c00404 	addi	r7,r7,16
  400790:	18c00404 	addi	r3,r3,16
  400794:	393ffc15 	stw	r4,-16(r7)
  400798:	1bbffc17 	ldw	r14,-16(r3)
  40079c:	6b400404 	addi	r13,r13,16
  4007a0:	5ac00404 	addi	r11,r11,16
  4007a4:	6bbffc15 	stw	r14,-16(r13)
  4007a8:	63800017 	ldw	r14,0(r12)
  4007ac:	4a400404 	addi	r9,r9,16
  4007b0:	42000404 	addi	r8,r8,16
  4007b4:	5bbffc15 	stw	r14,-16(r11)
  4007b8:	53800017 	ldw	r14,0(r10)
  4007bc:	63000404 	addi	r12,r12,16
  4007c0:	52800404 	addi	r10,r10,16
  4007c4:	4bbffc15 	stw	r14,-16(r9)
  4007c8:	1bffef1e 	bne	r3,r15,400788 <__alt_mem_flash_tristate_controller_0+0xfd400788>
  4007cc:	81c00044 	addi	r7,r16,1
  4007d0:	380e913a 	slli	r7,r7,4
  4007d4:	310003cc 	andi	r4,r6,15
  4007d8:	02c000c4 	movi	r11,3
  4007dc:	11c7883a 	add	r3,r2,r7
  4007e0:	29cb883a 	add	r5,r5,r7
  4007e4:	59001f2e 	bgeu	r11,r4,400864 <memcpy+0x130>
  4007e8:	1813883a 	mov	r9,r3
  4007ec:	2811883a 	mov	r8,r5
  4007f0:	200f883a 	mov	r7,r4
  4007f4:	42800017 	ldw	r10,0(r8)
  4007f8:	4a400104 	addi	r9,r9,4
  4007fc:	39ffff04 	addi	r7,r7,-4
  400800:	4abfff15 	stw	r10,-4(r9)
  400804:	42000104 	addi	r8,r8,4
  400808:	59fffa36 	bltu	r11,r7,4007f4 <__alt_mem_flash_tristate_controller_0+0xfd4007f4>
  40080c:	213fff04 	addi	r4,r4,-4
  400810:	2008d0ba 	srli	r4,r4,2
  400814:	318000cc 	andi	r6,r6,3
  400818:	21000044 	addi	r4,r4,1
  40081c:	2109883a 	add	r4,r4,r4
  400820:	2109883a 	add	r4,r4,r4
  400824:	1907883a 	add	r3,r3,r4
  400828:	290b883a 	add	r5,r5,r4
  40082c:	30000626 	beq	r6,zero,400848 <memcpy+0x114>
  400830:	198d883a 	add	r6,r3,r6
  400834:	29c00003 	ldbu	r7,0(r5)
  400838:	18c00044 	addi	r3,r3,1
  40083c:	29400044 	addi	r5,r5,1
  400840:	19ffffc5 	stb	r7,-1(r3)
  400844:	19bffb1e 	bne	r3,r6,400834 <__alt_mem_flash_tristate_controller_0+0xfd400834>
  400848:	dc000017 	ldw	r16,0(sp)
  40084c:	dec00104 	addi	sp,sp,4
  400850:	f800283a 	ret
  400854:	2007883a 	mov	r3,r4
  400858:	003ff406 	br	40082c <__alt_mem_flash_tristate_controller_0+0xfd40082c>
  40085c:	2007883a 	mov	r3,r4
  400860:	003ff306 	br	400830 <__alt_mem_flash_tristate_controller_0+0xfd400830>
  400864:	200d883a 	mov	r6,r4
  400868:	003ff006 	br	40082c <__alt_mem_flash_tristate_controller_0+0xfd40082c>

0040086c <__call_exitprocs>:
  40086c:	00801034 	movhi	r2,64
  400870:	1090bb04 	addi	r2,r2,17132
  400874:	10800017 	ldw	r2,0(r2)
  400878:	defff404 	addi	sp,sp,-48
  40087c:	dd800815 	stw	r22,32(sp)
  400880:	d8800015 	stw	r2,0(sp)
  400884:	10805204 	addi	r2,r2,328
  400888:	dd000615 	stw	r20,24(sp)
  40088c:	dc800415 	stw	r18,16(sp)
  400890:	dfc00b15 	stw	ra,44(sp)
  400894:	df000a15 	stw	fp,40(sp)
  400898:	ddc00915 	stw	r23,36(sp)
  40089c:	dd400715 	stw	r21,28(sp)
  4008a0:	dcc00515 	stw	r19,20(sp)
  4008a4:	dc400315 	stw	r17,12(sp)
  4008a8:	dc000215 	stw	r16,8(sp)
  4008ac:	2025883a 	mov	r18,r4
  4008b0:	2829883a 	mov	r20,r5
  4008b4:	d8800115 	stw	r2,4(sp)
  4008b8:	05bfffc4 	movi	r22,-1
  4008bc:	d8800017 	ldw	r2,0(sp)
  4008c0:	14c05217 	ldw	r19,328(r2)
  4008c4:	98001d26 	beq	r19,zero,40093c <__call_exitprocs+0xd0>
  4008c8:	dd400117 	ldw	r21,4(sp)
  4008cc:	98800117 	ldw	r2,4(r19)
  4008d0:	173fffc4 	addi	fp,r2,-1
  4008d4:	e0000d16 	blt	fp,zero,40090c <__call_exitprocs+0xa0>
  4008d8:	14000044 	addi	r16,r2,1
  4008dc:	8421883a 	add	r16,r16,r16
  4008e0:	8421883a 	add	r16,r16,r16
  4008e4:	84402004 	addi	r17,r16,128
  4008e8:	9c63883a 	add	r17,r19,r17
  4008ec:	9c21883a 	add	r16,r19,r16
  4008f0:	a0001e26 	beq	r20,zero,40096c <__call_exitprocs+0x100>
  4008f4:	80804017 	ldw	r2,256(r16)
  4008f8:	15001c26 	beq	r2,r20,40096c <__call_exitprocs+0x100>
  4008fc:	e73fffc4 	addi	fp,fp,-1
  400900:	843fff04 	addi	r16,r16,-4
  400904:	8c7fff04 	addi	r17,r17,-4
  400908:	e5bff91e 	bne	fp,r22,4008f0 <__alt_mem_flash_tristate_controller_0+0xfd4008f0>
  40090c:	00800034 	movhi	r2,0
  400910:	10800004 	addi	r2,r2,0
  400914:	10000926 	beq	r2,zero,40093c <__call_exitprocs+0xd0>
  400918:	98800117 	ldw	r2,4(r19)
  40091c:	1000311e 	bne	r2,zero,4009e4 <__call_exitprocs+0x178>
  400920:	98800017 	ldw	r2,0(r19)
  400924:	10003426 	beq	r2,zero,4009f8 <__call_exitprocs+0x18c>
  400928:	9809883a 	mov	r4,r19
  40092c:	a8800015 	stw	r2,0(r21)
  400930:	00000000 	call	0 <__alt_mem_constants-0x2000>
  400934:	acc00017 	ldw	r19,0(r21)
  400938:	983fe41e 	bne	r19,zero,4008cc <__alt_mem_flash_tristate_controller_0+0xfd4008cc>
  40093c:	dfc00b17 	ldw	ra,44(sp)
  400940:	df000a17 	ldw	fp,40(sp)
  400944:	ddc00917 	ldw	r23,36(sp)
  400948:	dd800817 	ldw	r22,32(sp)
  40094c:	dd400717 	ldw	r21,28(sp)
  400950:	dd000617 	ldw	r20,24(sp)
  400954:	dcc00517 	ldw	r19,20(sp)
  400958:	dc800417 	ldw	r18,16(sp)
  40095c:	dc400317 	ldw	r17,12(sp)
  400960:	dc000217 	ldw	r16,8(sp)
  400964:	dec00c04 	addi	sp,sp,48
  400968:	f800283a 	ret
  40096c:	98800117 	ldw	r2,4(r19)
  400970:	80c00017 	ldw	r3,0(r16)
  400974:	10bfffc4 	addi	r2,r2,-1
  400978:	17001526 	beq	r2,fp,4009d0 <__call_exitprocs+0x164>
  40097c:	80000015 	stw	zero,0(r16)
  400980:	183fde26 	beq	r3,zero,4008fc <__alt_mem_flash_tristate_controller_0+0xfd4008fc>
  400984:	00800044 	movi	r2,1
  400988:	1708983a 	sll	r4,r2,fp
  40098c:	98806217 	ldw	r2,392(r19)
  400990:	9dc00117 	ldw	r23,4(r19)
  400994:	2084703a 	and	r2,r4,r2
  400998:	1000061e 	bne	r2,zero,4009b4 <__call_exitprocs+0x148>
  40099c:	183ee83a 	callr	r3
  4009a0:	98800117 	ldw	r2,4(r19)
  4009a4:	15ffc51e 	bne	r2,r23,4008bc <__alt_mem_flash_tristate_controller_0+0xfd4008bc>
  4009a8:	a8800017 	ldw	r2,0(r21)
  4009ac:	14ffd326 	beq	r2,r19,4008fc <__alt_mem_flash_tristate_controller_0+0xfd4008fc>
  4009b0:	003fc206 	br	4008bc <__alt_mem_flash_tristate_controller_0+0xfd4008bc>
  4009b4:	98806317 	ldw	r2,396(r19)
  4009b8:	2084703a 	and	r2,r4,r2
  4009bc:	1000061e 	bne	r2,zero,4009d8 <__call_exitprocs+0x16c>
  4009c0:	89400017 	ldw	r5,0(r17)
  4009c4:	9009883a 	mov	r4,r18
  4009c8:	183ee83a 	callr	r3
  4009cc:	003ff406 	br	4009a0 <__alt_mem_flash_tristate_controller_0+0xfd4009a0>
  4009d0:	9f000115 	stw	fp,4(r19)
  4009d4:	003fea06 	br	400980 <__alt_mem_flash_tristate_controller_0+0xfd400980>
  4009d8:	89000017 	ldw	r4,0(r17)
  4009dc:	183ee83a 	callr	r3
  4009e0:	003fef06 	br	4009a0 <__alt_mem_flash_tristate_controller_0+0xfd4009a0>
  4009e4:	98800017 	ldw	r2,0(r19)
  4009e8:	982b883a 	mov	r21,r19
  4009ec:	1027883a 	mov	r19,r2
  4009f0:	983fb61e 	bne	r19,zero,4008cc <__alt_mem_flash_tristate_controller_0+0xfd4008cc>
  4009f4:	003fd106 	br	40093c <__alt_mem_flash_tristate_controller_0+0xfd40093c>
  4009f8:	0005883a 	mov	r2,zero
  4009fc:	003ffa06 	br	4009e8 <__alt_mem_flash_tristate_controller_0+0xfd4009e8>

00400a00 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
  400a00:	defffe04 	addi	sp,sp,-8
  400a04:	df000115 	stw	fp,4(sp)
  400a08:	df000104 	addi	fp,sp,4
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  400a0c:	e03fff15 	stw	zero,-4(fp)
  400a10:	00000506 	br	400a28 <alt_dcache_flush_all+0x28>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  400a14:	e0bfff17 	ldw	r2,-4(fp)
  400a18:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  400a1c:	e0bfff17 	ldw	r2,-4(fp)
  400a20:	10800804 	addi	r2,r2,32
  400a24:	e0bfff15 	stw	r2,-4(fp)
  400a28:	e0bfff17 	ldw	r2,-4(fp)
  400a2c:	10820030 	cmpltui	r2,r2,2048
  400a30:	103ff81e 	bne	r2,zero,400a14 <__alt_mem_flash_tristate_controller_0+0xfd400a14>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
  400a34:	e037883a 	mov	sp,fp
  400a38:	df000017 	ldw	fp,0(sp)
  400a3c:	dec00104 	addi	sp,sp,4
  400a40:	f800283a 	ret

00400a44 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
  400a44:	defffd04 	addi	sp,sp,-12
  400a48:	df000215 	stw	fp,8(sp)
  400a4c:	df000204 	addi	fp,sp,8
  400a50:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
  400a54:	0001883a 	nop
  400a58:	e0bfff17 	ldw	r2,-4(fp)
  400a5c:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
  400a60:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
  400a64:	10000226 	beq	r2,zero,400a70 <_exit+0x2c>
    ALT_SIM_FAIL();
  400a68:	002af070 	cmpltui	zero,zero,43969
  400a6c:	00000106 	br	400a74 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
  400a70:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
  400a74:	003fff06 	br	400a74 <__alt_mem_flash_tristate_controller_0+0xfd400a74>

00400a78 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
  400a78:	defffe04 	addi	sp,sp,-8
  400a7c:	dfc00115 	stw	ra,4(sp)
  400a80:	df000015 	stw	fp,0(sp)
  400a84:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
  400a88:	0009883a 	mov	r4,zero
  400a8c:	01440004 	movi	r5,4096
  400a90:	04024b40 	call	4024b4 <alt_icache_flush>
#endif
}
  400a94:	e037883a 	mov	sp,fp
  400a98:	dfc00117 	ldw	ra,4(sp)
  400a9c:	df000017 	ldw	fp,0(sp)
  400aa0:	dec00204 	addi	sp,sp,8
  400aa4:	f800283a 	ret

00400aa8 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  400aa8:	defffc04 	addi	sp,sp,-16
  400aac:	df000315 	stw	fp,12(sp)
  400ab0:	df000304 	addi	fp,sp,12
  400ab4:	e13ffd15 	stw	r4,-12(fp)
  400ab8:	e17ffe15 	stw	r5,-8(fp)
  400abc:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
  400ac0:	e0fffe17 	ldw	r3,-8(fp)
  400ac4:	e0bffd17 	ldw	r2,-12(fp)
  400ac8:	18800c26 	beq	r3,r2,400afc <alt_load_section+0x54>
  {
    while( to != end )
  400acc:	00000806 	br	400af0 <alt_load_section+0x48>
    {
      *to++ = *from++;
  400ad0:	e0bffe17 	ldw	r2,-8(fp)
  400ad4:	10c00104 	addi	r3,r2,4
  400ad8:	e0fffe15 	stw	r3,-8(fp)
  400adc:	e0fffd17 	ldw	r3,-12(fp)
  400ae0:	19000104 	addi	r4,r3,4
  400ae4:	e13ffd15 	stw	r4,-12(fp)
  400ae8:	18c00017 	ldw	r3,0(r3)
  400aec:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
  400af0:	e0fffe17 	ldw	r3,-8(fp)
  400af4:	e0bfff17 	ldw	r2,-4(fp)
  400af8:	18bff51e 	bne	r3,r2,400ad0 <__alt_mem_flash_tristate_controller_0+0xfd400ad0>
    {
      *to++ = *from++;
    }
  }
}
  400afc:	e037883a 	mov	sp,fp
  400b00:	df000017 	ldw	fp,0(sp)
  400b04:	dec00104 	addi	sp,sp,4
  400b08:	f800283a 	ret

00400b0c <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
  400b0c:	defffe04 	addi	sp,sp,-8
  400b10:	dfc00115 	stw	ra,4(sp)
  400b14:	df000015 	stw	fp,0(sp)
  400b18:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
  400b1c:	01001034 	movhi	r4,64
  400b20:	2110c604 	addi	r4,r4,17176
  400b24:	01401034 	movhi	r5,64
  400b28:	294ace04 	addi	r5,r5,11064
  400b2c:	01801034 	movhi	r6,64
  400b30:	3190c604 	addi	r6,r6,17176
  400b34:	0400aa80 	call	400aa8 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
  400b38:	01001034 	movhi	r4,64
  400b3c:	21000804 	addi	r4,r4,32
  400b40:	01401034 	movhi	r5,64
  400b44:	29400804 	addi	r5,r5,32
  400b48:	01801034 	movhi	r6,64
  400b4c:	31806f04 	addi	r6,r6,444
  400b50:	0400aa80 	call	400aa8 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
  400b54:	01001034 	movhi	r4,64
  400b58:	210abe04 	addi	r4,r4,11000
  400b5c:	01401034 	movhi	r5,64
  400b60:	294abe04 	addi	r5,r5,11000
  400b64:	01801034 	movhi	r6,64
  400b68:	318ace04 	addi	r6,r6,11064
  400b6c:	0400aa80 	call	400aa8 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  400b70:	0400a000 	call	400a00 <alt_dcache_flush_all>
  alt_icache_flush_all();
  400b74:	0400a780 	call	400a78 <alt_icache_flush_all>
}
  400b78:	e037883a 	mov	sp,fp
  400b7c:	dfc00117 	ldw	ra,4(sp)
  400b80:	df000017 	ldw	fp,0(sp)
  400b84:	dec00204 	addi	sp,sp,8
  400b88:	f800283a 	ret

00400b8c <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
  400b8c:	defffd04 	addi	sp,sp,-12
  400b90:	dfc00215 	stw	ra,8(sp)
  400b94:	df000115 	stw	fp,4(sp)
  400b98:	df000104 	addi	fp,sp,4
  400b9c:	e13fff15 	stw	r4,-4(fp)
  return alt_busy_sleep(us);
  400ba0:	e13fff17 	ldw	r4,-4(fp)
  400ba4:	040223c0 	call	40223c <alt_busy_sleep>
}
  400ba8:	e037883a 	mov	sp,fp
  400bac:	dfc00117 	ldw	ra,4(sp)
  400bb0:	df000017 	ldw	fp,0(sp)
  400bb4:	dec00204 	addi	sp,sp,8
  400bb8:	f800283a 	ret

00400bbc <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  400bbc:	defffd04 	addi	sp,sp,-12
  400bc0:	dfc00215 	stw	ra,8(sp)
  400bc4:	df000115 	stw	fp,4(sp)
  400bc8:	df000104 	addi	fp,sp,4
  400bcc:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
  400bd0:	e13fff17 	ldw	r4,-4(fp)
  400bd4:	01401034 	movhi	r5,64
  400bd8:	2950bf04 	addi	r5,r5,17148
  400bdc:	04024100 	call	402410 <alt_dev_llist_insert>
}
  400be0:	e037883a 	mov	sp,fp
  400be4:	dfc00117 	ldw	ra,4(sp)
  400be8:	df000017 	ldw	fp,0(sp)
  400bec:	dec00204 	addi	sp,sp,8
  400bf0:	f800283a 	ret

00400bf4 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
  400bf4:	defffd04 	addi	sp,sp,-12
  400bf8:	dfc00215 	stw	ra,8(sp)
  400bfc:	df000115 	stw	fp,4(sp)
  400c00:	df000104 	addi	fp,sp,4
  400c04:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( CPU_0, cpu_0);
  400c08:	04029ac0 	call	4029ac <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
  400c0c:	00800044 	movi	r2,1
  400c10:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
  400c14:	e037883a 	mov	sp,fp
  400c18:	dfc00117 	ldw	ra,4(sp)
  400c1c:	df000017 	ldw	fp,0(sp)
  400c20:	dec00204 	addi	sp,sp,8
  400c24:	f800283a 	ret

00400c28 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  400c28:	defffe04 	addi	sp,sp,-8
  400c2c:	dfc00115 	stw	ra,4(sp)
  400c30:	df000015 	stw	fp,0(sp)
  400c34:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
  400c38:	01001004 	movi	r4,64
  400c3c:	000b883a 	mov	r5,zero
  400c40:	01800304 	movi	r6,12
  400c44:	01c0fa04 	movi	r7,1000
  400c48:	04017840 	call	401784 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
  400c4c:	01001034 	movhi	r4,64
  400c50:	210be104 	addi	r4,r4,12164
  400c54:	000b883a 	mov	r5,zero
  400c58:	01800104 	movi	r6,4
  400c5c:	0400e280 	call	400e28 <altera_avalon_jtag_uart_init>
  400c60:	01001034 	movhi	r4,64
  400c64:	210bd704 	addi	r4,r4,12124
  400c68:	0400bbc0 	call	400bbc <alt_dev_reg>
    ALTERA_AVALON_SPI_INIT ( SPI_0, spi_0);
  400c6c:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( DEBUG_UART, debug_uart);
  400c70:	01001034 	movhi	r4,64
  400c74:	210ff904 	addi	r4,r4,16356
  400c78:	000b883a 	mov	r5,zero
  400c7c:	01800384 	movi	r6,14
  400c80:	040191c0 	call	40191c <altera_avalon_uart_init>
  400c84:	01001034 	movhi	r4,64
  400c88:	210fef04 	addi	r4,r4,16316
  400c8c:	0400bbc0 	call	400bbc <alt_dev_reg>
    ALTERA_AVALON_UART_INIT ( UART_0, uart_0);
  400c90:	01001034 	movhi	r4,64
  400c94:	21102a04 	addi	r4,r4,16552
  400c98:	000b883a 	mov	r5,zero
  400c9c:	01800344 	movi	r6,13
  400ca0:	040191c0 	call	40191c <altera_avalon_uart_init>
  400ca4:	01001034 	movhi	r4,64
  400ca8:	21102004 	addi	r4,r4,16512
  400cac:	0400bbc0 	call	400bbc <alt_dev_reg>
}
  400cb0:	e037883a 	mov	sp,fp
  400cb4:	dfc00117 	ldw	ra,4(sp)
  400cb8:	df000017 	ldw	fp,0(sp)
  400cbc:	dec00204 	addi	sp,sp,8
  400cc0:	f800283a 	ret

00400cc4 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  400cc4:	defffa04 	addi	sp,sp,-24
  400cc8:	dfc00515 	stw	ra,20(sp)
  400ccc:	df000415 	stw	fp,16(sp)
  400cd0:	df000404 	addi	fp,sp,16
  400cd4:	e13ffd15 	stw	r4,-12(fp)
  400cd8:	e17ffe15 	stw	r5,-8(fp)
  400cdc:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  400ce0:	e0bffd17 	ldw	r2,-12(fp)
  400ce4:	10800017 	ldw	r2,0(r2)
  400ce8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
  400cec:	e0bffc17 	ldw	r2,-16(fp)
  400cf0:	10c00a04 	addi	r3,r2,40
  400cf4:	e0bffd17 	ldw	r2,-12(fp)
  400cf8:	10800217 	ldw	r2,8(r2)
  400cfc:	1809883a 	mov	r4,r3
  400d00:	e17ffe17 	ldw	r5,-8(fp)
  400d04:	e1bfff17 	ldw	r6,-4(fp)
  400d08:	100f883a 	mov	r7,r2
  400d0c:	04012ec0 	call	4012ec <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
  400d10:	e037883a 	mov	sp,fp
  400d14:	dfc00117 	ldw	ra,4(sp)
  400d18:	df000017 	ldw	fp,0(sp)
  400d1c:	dec00204 	addi	sp,sp,8
  400d20:	f800283a 	ret

00400d24 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  400d24:	defffa04 	addi	sp,sp,-24
  400d28:	dfc00515 	stw	ra,20(sp)
  400d2c:	df000415 	stw	fp,16(sp)
  400d30:	df000404 	addi	fp,sp,16
  400d34:	e13ffd15 	stw	r4,-12(fp)
  400d38:	e17ffe15 	stw	r5,-8(fp)
  400d3c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  400d40:	e0bffd17 	ldw	r2,-12(fp)
  400d44:	10800017 	ldw	r2,0(r2)
  400d48:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
  400d4c:	e0bffc17 	ldw	r2,-16(fp)
  400d50:	10c00a04 	addi	r3,r2,40
  400d54:	e0bffd17 	ldw	r2,-12(fp)
  400d58:	10800217 	ldw	r2,8(r2)
  400d5c:	1809883a 	mov	r4,r3
  400d60:	e17ffe17 	ldw	r5,-8(fp)
  400d64:	e1bfff17 	ldw	r6,-4(fp)
  400d68:	100f883a 	mov	r7,r2
  400d6c:	04014f80 	call	4014f8 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
  400d70:	e037883a 	mov	sp,fp
  400d74:	dfc00117 	ldw	ra,4(sp)
  400d78:	df000017 	ldw	fp,0(sp)
  400d7c:	dec00204 	addi	sp,sp,8
  400d80:	f800283a 	ret

00400d84 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
  400d84:	defffc04 	addi	sp,sp,-16
  400d88:	dfc00315 	stw	ra,12(sp)
  400d8c:	df000215 	stw	fp,8(sp)
  400d90:	df000204 	addi	fp,sp,8
  400d94:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  400d98:	e0bfff17 	ldw	r2,-4(fp)
  400d9c:	10800017 	ldw	r2,0(r2)
  400da0:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
  400da4:	e0bffe17 	ldw	r2,-8(fp)
  400da8:	10c00a04 	addi	r3,r2,40
  400dac:	e0bfff17 	ldw	r2,-4(fp)
  400db0:	10800217 	ldw	r2,8(r2)
  400db4:	1809883a 	mov	r4,r3
  400db8:	100b883a 	mov	r5,r2
  400dbc:	04011980 	call	401198 <altera_avalon_jtag_uart_close>
}
  400dc0:	e037883a 	mov	sp,fp
  400dc4:	dfc00117 	ldw	ra,4(sp)
  400dc8:	df000017 	ldw	fp,0(sp)
  400dcc:	dec00204 	addi	sp,sp,8
  400dd0:	f800283a 	ret

00400dd4 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
  400dd4:	defffa04 	addi	sp,sp,-24
  400dd8:	dfc00515 	stw	ra,20(sp)
  400ddc:	df000415 	stw	fp,16(sp)
  400de0:	df000404 	addi	fp,sp,16
  400de4:	e13ffd15 	stw	r4,-12(fp)
  400de8:	e17ffe15 	stw	r5,-8(fp)
  400dec:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
  400df0:	e0bffd17 	ldw	r2,-12(fp)
  400df4:	10800017 	ldw	r2,0(r2)
  400df8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
  400dfc:	e0bffc17 	ldw	r2,-16(fp)
  400e00:	10800a04 	addi	r2,r2,40
  400e04:	1009883a 	mov	r4,r2
  400e08:	e17ffe17 	ldw	r5,-8(fp)
  400e0c:	e1bfff17 	ldw	r6,-4(fp)
  400e10:	04012000 	call	401200 <altera_avalon_jtag_uart_ioctl>
}
  400e14:	e037883a 	mov	sp,fp
  400e18:	dfc00117 	ldw	ra,4(sp)
  400e1c:	df000017 	ldw	fp,0(sp)
  400e20:	dec00204 	addi	sp,sp,8
  400e24:	f800283a 	ret

00400e28 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
  400e28:	defffa04 	addi	sp,sp,-24
  400e2c:	dfc00515 	stw	ra,20(sp)
  400e30:	df000415 	stw	fp,16(sp)
  400e34:	df000404 	addi	fp,sp,16
  400e38:	e13ffd15 	stw	r4,-12(fp)
  400e3c:	e17ffe15 	stw	r5,-8(fp)
  400e40:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  400e44:	e0bffd17 	ldw	r2,-12(fp)
  400e48:	00c00044 	movi	r3,1
  400e4c:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
  400e50:	e0bffd17 	ldw	r2,-12(fp)
  400e54:	10800017 	ldw	r2,0(r2)
  400e58:	10800104 	addi	r2,r2,4
  400e5c:	1007883a 	mov	r3,r2
  400e60:	e0bffd17 	ldw	r2,-12(fp)
  400e64:	10800817 	ldw	r2,32(r2)
  400e68:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
  400e6c:	e0fffe17 	ldw	r3,-8(fp)
  400e70:	e0bfff17 	ldw	r2,-4(fp)
  400e74:	d8000015 	stw	zero,0(sp)
  400e78:	1809883a 	mov	r4,r3
  400e7c:	100b883a 	mov	r5,r2
  400e80:	01801034 	movhi	r6,64
  400e84:	3183bb04 	addi	r6,r6,3820
  400e88:	e1fffd17 	ldw	r7,-12(fp)
  400e8c:	04025400 	call	402540 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
  400e90:	e0bffd17 	ldw	r2,-12(fp)
  400e94:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
  400e98:	e0bffd17 	ldw	r2,-12(fp)
  400e9c:	10c00204 	addi	r3,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
  400ea0:	00801034 	movhi	r2,64
  400ea4:	1096c104 	addi	r2,r2,23300
  400ea8:	10800017 	ldw	r2,0(r2)
  400eac:	1809883a 	mov	r4,r3
  400eb0:	100b883a 	mov	r5,r2
  400eb4:	01801034 	movhi	r6,64
  400eb8:	31843c04 	addi	r6,r6,4336
  400ebc:	e1fffd17 	ldw	r7,-12(fp)
  400ec0:	04020fc0 	call	4020fc <alt_alarm_start>
  400ec4:	1000040e 	bge	r2,zero,400ed8 <altera_avalon_jtag_uart_init+0xb0>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
  400ec8:	e0fffd17 	ldw	r3,-12(fp)
  400ecc:	00a00034 	movhi	r2,32768
  400ed0:	10bfffc4 	addi	r2,r2,-1
  400ed4:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
  400ed8:	e037883a 	mov	sp,fp
  400edc:	dfc00117 	ldw	ra,4(sp)
  400ee0:	df000017 	ldw	fp,0(sp)
  400ee4:	dec00204 	addi	sp,sp,8
  400ee8:	f800283a 	ret

00400eec <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
  400eec:	defff804 	addi	sp,sp,-32
  400ef0:	df000715 	stw	fp,28(sp)
  400ef4:	df000704 	addi	fp,sp,28
  400ef8:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
  400efc:	e0bfff17 	ldw	r2,-4(fp)
  400f00:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
  400f04:	e0bffb17 	ldw	r2,-20(fp)
  400f08:	10800017 	ldw	r2,0(r2)
  400f0c:	e0bffc15 	stw	r2,-16(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  400f10:	e0bffc17 	ldw	r2,-16(fp)
  400f14:	10800104 	addi	r2,r2,4
  400f18:	10800037 	ldwio	r2,0(r2)
  400f1c:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
  400f20:	e0bffd17 	ldw	r2,-12(fp)
  400f24:	1080c00c 	andi	r2,r2,768
  400f28:	1000011e 	bne	r2,zero,400f30 <altera_avalon_jtag_uart_irq+0x44>
      break;
  400f2c:	00006c06 	br	4010e0 <altera_avalon_jtag_uart_irq+0x1f4>

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
  400f30:	e0bffd17 	ldw	r2,-12(fp)
  400f34:	1080400c 	andi	r2,r2,256
  400f38:	10003426 	beq	r2,zero,40100c <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
  400f3c:	00800074 	movhi	r2,1
  400f40:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  400f44:	e0bffb17 	ldw	r2,-20(fp)
  400f48:	10800a17 	ldw	r2,40(r2)
  400f4c:	10800044 	addi	r2,r2,1
  400f50:	1081ffcc 	andi	r2,r2,2047
  400f54:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
  400f58:	e0bffb17 	ldw	r2,-20(fp)
  400f5c:	10c00b17 	ldw	r3,44(r2)
  400f60:	e0bffe17 	ldw	r2,-8(fp)
  400f64:	1880011e 	bne	r3,r2,400f6c <altera_avalon_jtag_uart_irq+0x80>
          break;
  400f68:	00001606 	br	400fc4 <altera_avalon_jtag_uart_irq+0xd8>

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
  400f6c:	e0bffc17 	ldw	r2,-16(fp)
  400f70:	10800037 	ldwio	r2,0(r2)
  400f74:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
  400f78:	e0bff917 	ldw	r2,-28(fp)
  400f7c:	10a0000c 	andi	r2,r2,32768
  400f80:	1000011e 	bne	r2,zero,400f88 <altera_avalon_jtag_uart_irq+0x9c>
          break;
  400f84:	00000f06 	br	400fc4 <altera_avalon_jtag_uart_irq+0xd8>

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
  400f88:	e0bffb17 	ldw	r2,-20(fp)
  400f8c:	10800a17 	ldw	r2,40(r2)
  400f90:	e0fff917 	ldw	r3,-28(fp)
  400f94:	1809883a 	mov	r4,r3
  400f98:	e0fffb17 	ldw	r3,-20(fp)
  400f9c:	1885883a 	add	r2,r3,r2
  400fa0:	10800e04 	addi	r2,r2,56
  400fa4:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  400fa8:	e0bffb17 	ldw	r2,-20(fp)
  400fac:	10800a17 	ldw	r2,40(r2)
  400fb0:	10800044 	addi	r2,r2,1
  400fb4:	10c1ffcc 	andi	r3,r2,2047
  400fb8:	e0bffb17 	ldw	r2,-20(fp)
  400fbc:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
  400fc0:	003fe006 	br	400f44 <__alt_mem_flash_tristate_controller_0+0xfd400f44>

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
  400fc4:	e0bff917 	ldw	r2,-28(fp)
  400fc8:	10bfffec 	andhi	r2,r2,65535
  400fcc:	10000f26 	beq	r2,zero,40100c <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  400fd0:	e0bffb17 	ldw	r2,-20(fp)
  400fd4:	10c00817 	ldw	r3,32(r2)
  400fd8:	00bfff84 	movi	r2,-2
  400fdc:	1886703a 	and	r3,r3,r2
  400fe0:	e0bffb17 	ldw	r2,-20(fp)
  400fe4:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
  400fe8:	e0bffc17 	ldw	r2,-16(fp)
  400fec:	10800104 	addi	r2,r2,4
  400ff0:	1007883a 	mov	r3,r2
  400ff4:	e0bffb17 	ldw	r2,-20(fp)
  400ff8:	10800817 	ldw	r2,32(r2)
  400ffc:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  401000:	e0bffc17 	ldw	r2,-16(fp)
  401004:	10800104 	addi	r2,r2,4
  401008:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
  40100c:	e0bffd17 	ldw	r2,-12(fp)
  401010:	1080800c 	andi	r2,r2,512
  401014:	10003126 	beq	r2,zero,4010dc <altera_avalon_jtag_uart_irq+0x1f0>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
  401018:	e0bffd17 	ldw	r2,-12(fp)
  40101c:	1004d43a 	srli	r2,r2,16
  401020:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
  401024:	00001406 	br	401078 <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
  401028:	e0bffc17 	ldw	r2,-16(fp)
  40102c:	e0fffb17 	ldw	r3,-20(fp)
  401030:	18c00d17 	ldw	r3,52(r3)
  401034:	e13ffb17 	ldw	r4,-20(fp)
  401038:	20c7883a 	add	r3,r4,r3
  40103c:	18c20e04 	addi	r3,r3,2104
  401040:	18c00003 	ldbu	r3,0(r3)
  401044:	18c03fcc 	andi	r3,r3,255
  401048:	18c0201c 	xori	r3,r3,128
  40104c:	18ffe004 	addi	r3,r3,-128
  401050:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  401054:	e0bffb17 	ldw	r2,-20(fp)
  401058:	10800d17 	ldw	r2,52(r2)
  40105c:	10800044 	addi	r2,r2,1
  401060:	10c1ffcc 	andi	r3,r2,2047
  401064:	e0bffb17 	ldw	r2,-20(fp)
  401068:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
  40106c:	e0bffa17 	ldw	r2,-24(fp)
  401070:	10bfffc4 	addi	r2,r2,-1
  401074:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
  401078:	e0bffa17 	ldw	r2,-24(fp)
  40107c:	10000526 	beq	r2,zero,401094 <altera_avalon_jtag_uart_irq+0x1a8>
  401080:	e0bffb17 	ldw	r2,-20(fp)
  401084:	10c00d17 	ldw	r3,52(r2)
  401088:	e0bffb17 	ldw	r2,-20(fp)
  40108c:	10800c17 	ldw	r2,48(r2)
  401090:	18bfe51e 	bne	r3,r2,401028 <__alt_mem_flash_tristate_controller_0+0xfd401028>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
  401094:	e0bffa17 	ldw	r2,-24(fp)
  401098:	10001026 	beq	r2,zero,4010dc <altera_avalon_jtag_uart_irq+0x1f0>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  40109c:	e0bffb17 	ldw	r2,-20(fp)
  4010a0:	10c00817 	ldw	r3,32(r2)
  4010a4:	00bfff44 	movi	r2,-3
  4010a8:	1886703a 	and	r3,r3,r2
  4010ac:	e0bffb17 	ldw	r2,-20(fp)
  4010b0:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  4010b4:	e0bffb17 	ldw	r2,-20(fp)
  4010b8:	10800017 	ldw	r2,0(r2)
  4010bc:	10800104 	addi	r2,r2,4
  4010c0:	1007883a 	mov	r3,r2
  4010c4:	e0bffb17 	ldw	r2,-20(fp)
  4010c8:	10800817 	ldw	r2,32(r2)
  4010cc:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  4010d0:	e0bffc17 	ldw	r2,-16(fp)
  4010d4:	10800104 	addi	r2,r2,4
  4010d8:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
  4010dc:	003f8c06 	br	400f10 <__alt_mem_flash_tristate_controller_0+0xfd400f10>
}
  4010e0:	e037883a 	mov	sp,fp
  4010e4:	df000017 	ldw	fp,0(sp)
  4010e8:	dec00104 	addi	sp,sp,4
  4010ec:	f800283a 	ret

004010f0 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
  4010f0:	defff804 	addi	sp,sp,-32
  4010f4:	df000715 	stw	fp,28(sp)
  4010f8:	df000704 	addi	fp,sp,28
  4010fc:	e13ffb15 	stw	r4,-20(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
  401100:	e0bffb17 	ldw	r2,-20(fp)
  401104:	e0bff915 	stw	r2,-28(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
  401108:	e0bff917 	ldw	r2,-28(fp)
  40110c:	10800017 	ldw	r2,0(r2)
  401110:	10800104 	addi	r2,r2,4
  401114:	10800037 	ldwio	r2,0(r2)
  401118:	e0bffa15 	stw	r2,-24(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
  40111c:	e0bffa17 	ldw	r2,-24(fp)
  401120:	1081000c 	andi	r2,r2,1024
  401124:	10000b26 	beq	r2,zero,401154 <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
  401128:	e0bff917 	ldw	r2,-28(fp)
  40112c:	10800017 	ldw	r2,0(r2)
  401130:	10800104 	addi	r2,r2,4
  401134:	1007883a 	mov	r3,r2
  401138:	e0bff917 	ldw	r2,-28(fp)
  40113c:	10800817 	ldw	r2,32(r2)
  401140:	10810014 	ori	r2,r2,1024
  401144:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
  401148:	e0bff917 	ldw	r2,-28(fp)
  40114c:	10000915 	stw	zero,36(r2)
  401150:	00000a06 	br	40117c <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
  401154:	e0bff917 	ldw	r2,-28(fp)
  401158:	10c00917 	ldw	r3,36(r2)
  40115c:	00a00034 	movhi	r2,32768
  401160:	10bfff04 	addi	r2,r2,-4
  401164:	10c00536 	bltu	r2,r3,40117c <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
  401168:	e0bff917 	ldw	r2,-28(fp)
  40116c:	10800917 	ldw	r2,36(r2)
  401170:	10c00044 	addi	r3,r2,1
  401174:	e0bff917 	ldw	r2,-28(fp)
  401178:	10c00915 	stw	r3,36(r2)
  40117c:	00801034 	movhi	r2,64
  401180:	1096c104 	addi	r2,r2,23300
  401184:	10800017 	ldw	r2,0(r2)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
  401188:	e037883a 	mov	sp,fp
  40118c:	df000017 	ldw	fp,0(sp)
  401190:	dec00104 	addi	sp,sp,4
  401194:	f800283a 	ret

00401198 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
  401198:	defffd04 	addi	sp,sp,-12
  40119c:	df000215 	stw	fp,8(sp)
  4011a0:	df000204 	addi	fp,sp,8
  4011a4:	e13ffe15 	stw	r4,-8(fp)
  4011a8:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  4011ac:	00000506 	br	4011c4 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
  4011b0:	e0bfff17 	ldw	r2,-4(fp)
  4011b4:	1090000c 	andi	r2,r2,16384
  4011b8:	10000226 	beq	r2,zero,4011c4 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
  4011bc:	00bffd44 	movi	r2,-11
  4011c0:	00000b06 	br	4011f0 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  4011c4:	e0bffe17 	ldw	r2,-8(fp)
  4011c8:	10c00d17 	ldw	r3,52(r2)
  4011cc:	e0bffe17 	ldw	r2,-8(fp)
  4011d0:	10800c17 	ldw	r2,48(r2)
  4011d4:	18800526 	beq	r3,r2,4011ec <altera_avalon_jtag_uart_close+0x54>
  4011d8:	e0bffe17 	ldw	r2,-8(fp)
  4011dc:	10c00917 	ldw	r3,36(r2)
  4011e0:	e0bffe17 	ldw	r2,-8(fp)
  4011e4:	10800117 	ldw	r2,4(r2)
  4011e8:	18bff136 	bltu	r3,r2,4011b0 <__alt_mem_flash_tristate_controller_0+0xfd4011b0>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
  4011ec:	0005883a 	mov	r2,zero
}
  4011f0:	e037883a 	mov	sp,fp
  4011f4:	df000017 	ldw	fp,0(sp)
  4011f8:	dec00104 	addi	sp,sp,4
  4011fc:	f800283a 	ret

00401200 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
  401200:	defffa04 	addi	sp,sp,-24
  401204:	df000515 	stw	fp,20(sp)
  401208:	df000504 	addi	fp,sp,20
  40120c:	e13ffd15 	stw	r4,-12(fp)
  401210:	e17ffe15 	stw	r5,-8(fp)
  401214:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
  401218:	00bff9c4 	movi	r2,-25
  40121c:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
  401220:	e0bffe17 	ldw	r2,-8(fp)
  401224:	10da8060 	cmpeqi	r3,r2,27137
  401228:	1800031e 	bne	r3,zero,401238 <altera_avalon_jtag_uart_ioctl+0x38>
  40122c:	109a80a0 	cmpeqi	r2,r2,27138
  401230:	1000191e 	bne	r2,zero,401298 <altera_avalon_jtag_uart_ioctl+0x98>
      rc = 0;
    }
    break;

  default:
    break;
  401234:	00002806 	br	4012d8 <altera_avalon_jtag_uart_ioctl+0xd8>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
  401238:	e0bffd17 	ldw	r2,-12(fp)
  40123c:	10c00117 	ldw	r3,4(r2)
  401240:	00a00034 	movhi	r2,32768
  401244:	10bfffc4 	addi	r2,r2,-1
  401248:	18801226 	beq	r3,r2,401294 <altera_avalon_jtag_uart_ioctl+0x94>
    {
      int timeout = *((int *)arg);
  40124c:	e0bfff17 	ldw	r2,-4(fp)
  401250:	10800017 	ldw	r2,0(r2)
  401254:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
  401258:	e0bffc17 	ldw	r2,-16(fp)
  40125c:	10800090 	cmplti	r2,r2,2
  401260:	1000061e 	bne	r2,zero,40127c <altera_avalon_jtag_uart_ioctl+0x7c>
  401264:	e0fffc17 	ldw	r3,-16(fp)
  401268:	00a00034 	movhi	r2,32768
  40126c:	10bfffc4 	addi	r2,r2,-1
  401270:	18800226 	beq	r3,r2,40127c <altera_avalon_jtag_uart_ioctl+0x7c>
  401274:	e0bffc17 	ldw	r2,-16(fp)
  401278:	00000206 	br	401284 <altera_avalon_jtag_uart_ioctl+0x84>
  40127c:	00a00034 	movhi	r2,32768
  401280:	10bfff84 	addi	r2,r2,-2
  401284:	e0fffd17 	ldw	r3,-12(fp)
  401288:	18800115 	stw	r2,4(r3)
      rc = 0;
  40128c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
  401290:	00001106 	br	4012d8 <altera_avalon_jtag_uart_ioctl+0xd8>
  401294:	00001006 	br	4012d8 <altera_avalon_jtag_uart_ioctl+0xd8>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
  401298:	e0bffd17 	ldw	r2,-12(fp)
  40129c:	10c00117 	ldw	r3,4(r2)
  4012a0:	00a00034 	movhi	r2,32768
  4012a4:	10bfffc4 	addi	r2,r2,-1
  4012a8:	18800a26 	beq	r3,r2,4012d4 <altera_avalon_jtag_uart_ioctl+0xd4>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
  4012ac:	e0bffd17 	ldw	r2,-12(fp)
  4012b0:	10c00917 	ldw	r3,36(r2)
  4012b4:	e0bffd17 	ldw	r2,-12(fp)
  4012b8:	10800117 	ldw	r2,4(r2)
  4012bc:	1885803a 	cmpltu	r2,r3,r2
  4012c0:	10c03fcc 	andi	r3,r2,255
  4012c4:	e0bfff17 	ldw	r2,-4(fp)
  4012c8:	10c00015 	stw	r3,0(r2)
      rc = 0;
  4012cc:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
  4012d0:	00000006 	br	4012d4 <altera_avalon_jtag_uart_ioctl+0xd4>
  4012d4:	0001883a 	nop

  default:
    break;
  }

  return rc;
  4012d8:	e0bffb17 	ldw	r2,-20(fp)
}
  4012dc:	e037883a 	mov	sp,fp
  4012e0:	df000017 	ldw	fp,0(sp)
  4012e4:	dec00104 	addi	sp,sp,4
  4012e8:	f800283a 	ret

004012ec <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
  4012ec:	defff304 	addi	sp,sp,-52
  4012f0:	dfc00c15 	stw	ra,48(sp)
  4012f4:	df000b15 	stw	fp,44(sp)
  4012f8:	df000b04 	addi	fp,sp,44
  4012fc:	e13ffc15 	stw	r4,-16(fp)
  401300:	e17ffd15 	stw	r5,-12(fp)
  401304:	e1bffe15 	stw	r6,-8(fp)
  401308:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
  40130c:	e0bffd17 	ldw	r2,-12(fp)
  401310:	e0bff515 	stw	r2,-44(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
  401314:	00004906 	br	40143c <altera_avalon_jtag_uart_read+0x150>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
  401318:	e0bffc17 	ldw	r2,-16(fp)
  40131c:	10800a17 	ldw	r2,40(r2)
  401320:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
  401324:	e0bffc17 	ldw	r2,-16(fp)
  401328:	10800b17 	ldw	r2,44(r2)
  40132c:	e0bff815 	stw	r2,-32(fp)

      if (in >= out)
  401330:	e0fff717 	ldw	r3,-36(fp)
  401334:	e0bff817 	ldw	r2,-32(fp)
  401338:	18800536 	bltu	r3,r2,401350 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
  40133c:	e0fff717 	ldw	r3,-36(fp)
  401340:	e0bff817 	ldw	r2,-32(fp)
  401344:	1885c83a 	sub	r2,r3,r2
  401348:	e0bff615 	stw	r2,-40(fp)
  40134c:	00000406 	br	401360 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
  401350:	00c20004 	movi	r3,2048
  401354:	e0bff817 	ldw	r2,-32(fp)
  401358:	1885c83a 	sub	r2,r3,r2
  40135c:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
  401360:	e0bff617 	ldw	r2,-40(fp)
  401364:	1000011e 	bne	r2,zero,40136c <altera_avalon_jtag_uart_read+0x80>
        break; /* No more data available */
  401368:	00001d06 	br	4013e0 <altera_avalon_jtag_uart_read+0xf4>

      if (n > space)
  40136c:	e0fffe17 	ldw	r3,-8(fp)
  401370:	e0bff617 	ldw	r2,-40(fp)
  401374:	1880022e 	bgeu	r3,r2,401380 <altera_avalon_jtag_uart_read+0x94>
        n = space;
  401378:	e0bffe17 	ldw	r2,-8(fp)
  40137c:	e0bff615 	stw	r2,-40(fp)

      memcpy(ptr, sp->rx_buf + out, n);
  401380:	e0bff817 	ldw	r2,-32(fp)
  401384:	10800e04 	addi	r2,r2,56
  401388:	e0fffc17 	ldw	r3,-16(fp)
  40138c:	1885883a 	add	r2,r3,r2
  401390:	e13ff517 	ldw	r4,-44(fp)
  401394:	100b883a 	mov	r5,r2
  401398:	e1bff617 	ldw	r6,-40(fp)
  40139c:	04007340 	call	400734 <memcpy>
      ptr   += n;
  4013a0:	e0fff517 	ldw	r3,-44(fp)
  4013a4:	e0bff617 	ldw	r2,-40(fp)
  4013a8:	1885883a 	add	r2,r3,r2
  4013ac:	e0bff515 	stw	r2,-44(fp)
      space -= n;
  4013b0:	e0fffe17 	ldw	r3,-8(fp)
  4013b4:	e0bff617 	ldw	r2,-40(fp)
  4013b8:	1885c83a 	sub	r2,r3,r2
  4013bc:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  4013c0:	e0fff817 	ldw	r3,-32(fp)
  4013c4:	e0bff617 	ldw	r2,-40(fp)
  4013c8:	1885883a 	add	r2,r3,r2
  4013cc:	10c1ffcc 	andi	r3,r2,2047
  4013d0:	e0bffc17 	ldw	r2,-16(fp)
  4013d4:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
  4013d8:	e0bffe17 	ldw	r2,-8(fp)
  4013dc:	00bfce16 	blt	zero,r2,401318 <__alt_mem_flash_tristate_controller_0+0xfd401318>

    /* If we read any data then return it */
    if (ptr != buffer)
  4013e0:	e0fff517 	ldw	r3,-44(fp)
  4013e4:	e0bffd17 	ldw	r2,-12(fp)
  4013e8:	18800126 	beq	r3,r2,4013f0 <altera_avalon_jtag_uart_read+0x104>
      break;
  4013ec:	00001506 	br	401444 <altera_avalon_jtag_uart_read+0x158>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
  4013f0:	e0bfff17 	ldw	r2,-4(fp)
  4013f4:	1090000c 	andi	r2,r2,16384
  4013f8:	10000126 	beq	r2,zero,401400 <altera_avalon_jtag_uart_read+0x114>
      break;
  4013fc:	00001106 	br	401444 <altera_avalon_jtag_uart_read+0x158>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
  401400:	0001883a 	nop
  401404:	e0bffc17 	ldw	r2,-16(fp)
  401408:	10c00a17 	ldw	r3,40(r2)
  40140c:	e0bff717 	ldw	r2,-36(fp)
  401410:	1880051e 	bne	r3,r2,401428 <altera_avalon_jtag_uart_read+0x13c>
  401414:	e0bffc17 	ldw	r2,-16(fp)
  401418:	10c00917 	ldw	r3,36(r2)
  40141c:	e0bffc17 	ldw	r2,-16(fp)
  401420:	10800117 	ldw	r2,4(r2)
  401424:	18bff736 	bltu	r3,r2,401404 <__alt_mem_flash_tristate_controller_0+0xfd401404>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
  401428:	e0bffc17 	ldw	r2,-16(fp)
  40142c:	10c00a17 	ldw	r3,40(r2)
  401430:	e0bff717 	ldw	r2,-36(fp)
  401434:	1880011e 	bne	r3,r2,40143c <altera_avalon_jtag_uart_read+0x150>
      break;
  401438:	00000206 	br	401444 <altera_avalon_jtag_uart_read+0x158>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
  40143c:	e0bffe17 	ldw	r2,-8(fp)
  401440:	00bfb516 	blt	zero,r2,401318 <__alt_mem_flash_tristate_controller_0+0xfd401318>
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
  401444:	e0fff517 	ldw	r3,-44(fp)
  401448:	e0bffd17 	ldw	r2,-12(fp)
  40144c:	18801826 	beq	r3,r2,4014b0 <altera_avalon_jtag_uart_read+0x1c4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  401450:	0005303a 	rdctl	r2,status
  401454:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  401458:	e0fffa17 	ldw	r3,-24(fp)
  40145c:	00bfff84 	movi	r2,-2
  401460:	1884703a 	and	r2,r3,r2
  401464:	1001703a 	wrctl	status,r2
  
  return context;
  401468:	e0bffa17 	ldw	r2,-24(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
  40146c:	e0bff915 	stw	r2,-28(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  401470:	e0bffc17 	ldw	r2,-16(fp)
  401474:	10800817 	ldw	r2,32(r2)
  401478:	10c00054 	ori	r3,r2,1
  40147c:	e0bffc17 	ldw	r2,-16(fp)
  401480:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  401484:	e0bffc17 	ldw	r2,-16(fp)
  401488:	10800017 	ldw	r2,0(r2)
  40148c:	10800104 	addi	r2,r2,4
  401490:	1007883a 	mov	r3,r2
  401494:	e0bffc17 	ldw	r2,-16(fp)
  401498:	10800817 	ldw	r2,32(r2)
  40149c:	18800035 	stwio	r2,0(r3)
  4014a0:	e0bff917 	ldw	r2,-28(fp)
  4014a4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  4014a8:	e0bffb17 	ldw	r2,-20(fp)
  4014ac:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
  4014b0:	e0fff517 	ldw	r3,-44(fp)
  4014b4:	e0bffd17 	ldw	r2,-12(fp)
  4014b8:	18800426 	beq	r3,r2,4014cc <altera_avalon_jtag_uart_read+0x1e0>
    return ptr - buffer;
  4014bc:	e0fff517 	ldw	r3,-44(fp)
  4014c0:	e0bffd17 	ldw	r2,-12(fp)
  4014c4:	1885c83a 	sub	r2,r3,r2
  4014c8:	00000606 	br	4014e4 <altera_avalon_jtag_uart_read+0x1f8>
  else if (flags & O_NONBLOCK)
  4014cc:	e0bfff17 	ldw	r2,-4(fp)
  4014d0:	1090000c 	andi	r2,r2,16384
  4014d4:	10000226 	beq	r2,zero,4014e0 <altera_avalon_jtag_uart_read+0x1f4>
    return -EWOULDBLOCK;
  4014d8:	00bffd44 	movi	r2,-11
  4014dc:	00000106 	br	4014e4 <altera_avalon_jtag_uart_read+0x1f8>
  else
    return -EIO;
  4014e0:	00bffec4 	movi	r2,-5
}
  4014e4:	e037883a 	mov	sp,fp
  4014e8:	dfc00117 	ldw	ra,4(sp)
  4014ec:	df000017 	ldw	fp,0(sp)
  4014f0:	dec00204 	addi	sp,sp,8
  4014f4:	f800283a 	ret

004014f8 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  4014f8:	defff304 	addi	sp,sp,-52
  4014fc:	dfc00c15 	stw	ra,48(sp)
  401500:	df000b15 	stw	fp,44(sp)
  401504:	df000b04 	addi	fp,sp,44
  401508:	e13ffc15 	stw	r4,-16(fp)
  40150c:	e17ffd15 	stw	r5,-12(fp)
  401510:	e1bffe15 	stw	r6,-8(fp)
  401514:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
  401518:	e03ff515 	stw	zero,-44(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
  40151c:	e0bffd17 	ldw	r2,-12(fp)
  401520:	e0bff715 	stw	r2,-36(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
  401524:	00003806 	br	401608 <altera_avalon_jtag_uart_write+0x110>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
  401528:	e0bffc17 	ldw	r2,-16(fp)
  40152c:	10800c17 	ldw	r2,48(r2)
  401530:	e0bff815 	stw	r2,-32(fp)
      out = sp->tx_out;
  401534:	e0bffc17 	ldw	r2,-16(fp)
  401538:	10800d17 	ldw	r2,52(r2)
  40153c:	e0bff515 	stw	r2,-44(fp)

      if (in < out)
  401540:	e0fff817 	ldw	r3,-32(fp)
  401544:	e0bff517 	ldw	r2,-44(fp)
  401548:	1880062e 	bgeu	r3,r2,401564 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
  40154c:	e0fff517 	ldw	r3,-44(fp)
  401550:	e0bff817 	ldw	r2,-32(fp)
  401554:	1885c83a 	sub	r2,r3,r2
  401558:	10bfffc4 	addi	r2,r2,-1
  40155c:	e0bff615 	stw	r2,-40(fp)
  401560:	00000b06 	br	401590 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
  401564:	e0bff517 	ldw	r2,-44(fp)
  401568:	10000526 	beq	r2,zero,401580 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
  40156c:	00c20004 	movi	r3,2048
  401570:	e0bff817 	ldw	r2,-32(fp)
  401574:	1885c83a 	sub	r2,r3,r2
  401578:	e0bff615 	stw	r2,-40(fp)
  40157c:	00000406 	br	401590 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
  401580:	00c1ffc4 	movi	r3,2047
  401584:	e0bff817 	ldw	r2,-32(fp)
  401588:	1885c83a 	sub	r2,r3,r2
  40158c:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
  401590:	e0bff617 	ldw	r2,-40(fp)
  401594:	1000011e 	bne	r2,zero,40159c <altera_avalon_jtag_uart_write+0xa4>
        break;
  401598:	00001d06 	br	401610 <altera_avalon_jtag_uart_write+0x118>

      if (n > count)
  40159c:	e0fffe17 	ldw	r3,-8(fp)
  4015a0:	e0bff617 	ldw	r2,-40(fp)
  4015a4:	1880022e 	bgeu	r3,r2,4015b0 <altera_avalon_jtag_uart_write+0xb8>
        n = count;
  4015a8:	e0bffe17 	ldw	r2,-8(fp)
  4015ac:	e0bff615 	stw	r2,-40(fp)

      memcpy(sp->tx_buf + in, ptr, n);
  4015b0:	e0bff817 	ldw	r2,-32(fp)
  4015b4:	10820e04 	addi	r2,r2,2104
  4015b8:	e0fffc17 	ldw	r3,-16(fp)
  4015bc:	1885883a 	add	r2,r3,r2
  4015c0:	1009883a 	mov	r4,r2
  4015c4:	e17ffd17 	ldw	r5,-12(fp)
  4015c8:	e1bff617 	ldw	r6,-40(fp)
  4015cc:	04007340 	call	400734 <memcpy>
      ptr   += n;
  4015d0:	e0fffd17 	ldw	r3,-12(fp)
  4015d4:	e0bff617 	ldw	r2,-40(fp)
  4015d8:	1885883a 	add	r2,r3,r2
  4015dc:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
  4015e0:	e0fffe17 	ldw	r3,-8(fp)
  4015e4:	e0bff617 	ldw	r2,-40(fp)
  4015e8:	1885c83a 	sub	r2,r3,r2
  4015ec:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  4015f0:	e0fff817 	ldw	r3,-32(fp)
  4015f4:	e0bff617 	ldw	r2,-40(fp)
  4015f8:	1885883a 	add	r2,r3,r2
  4015fc:	10c1ffcc 	andi	r3,r2,2047
  401600:	e0bffc17 	ldw	r2,-16(fp)
  401604:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
  401608:	e0bffe17 	ldw	r2,-8(fp)
  40160c:	00bfc616 	blt	zero,r2,401528 <__alt_mem_flash_tristate_controller_0+0xfd401528>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  401610:	0005303a 	rdctl	r2,status
  401614:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  401618:	e0fffa17 	ldw	r3,-24(fp)
  40161c:	00bfff84 	movi	r2,-2
  401620:	1884703a 	and	r2,r3,r2
  401624:	1001703a 	wrctl	status,r2
  
  return context;
  401628:	e0bffa17 	ldw	r2,-24(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
  40162c:	e0bff915 	stw	r2,-28(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  401630:	e0bffc17 	ldw	r2,-16(fp)
  401634:	10800817 	ldw	r2,32(r2)
  401638:	10c00094 	ori	r3,r2,2
  40163c:	e0bffc17 	ldw	r2,-16(fp)
  401640:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  401644:	e0bffc17 	ldw	r2,-16(fp)
  401648:	10800017 	ldw	r2,0(r2)
  40164c:	10800104 	addi	r2,r2,4
  401650:	1007883a 	mov	r3,r2
  401654:	e0bffc17 	ldw	r2,-16(fp)
  401658:	10800817 	ldw	r2,32(r2)
  40165c:	18800035 	stwio	r2,0(r3)
  401660:	e0bff917 	ldw	r2,-28(fp)
  401664:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  401668:	e0bffb17 	ldw	r2,-20(fp)
  40166c:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
  401670:	e0bffe17 	ldw	r2,-8(fp)
  401674:	0080120e 	bge	zero,r2,4016c0 <altera_avalon_jtag_uart_write+0x1c8>
    {
      if (flags & O_NONBLOCK)
  401678:	e0bfff17 	ldw	r2,-4(fp)
  40167c:	1090000c 	andi	r2,r2,16384
  401680:	10000126 	beq	r2,zero,401688 <altera_avalon_jtag_uart_write+0x190>
        break;
  401684:	00001006 	br	4016c8 <altera_avalon_jtag_uart_write+0x1d0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
  401688:	0001883a 	nop
  40168c:	e0bffc17 	ldw	r2,-16(fp)
  401690:	10c00d17 	ldw	r3,52(r2)
  401694:	e0bff517 	ldw	r2,-44(fp)
  401698:	1880051e 	bne	r3,r2,4016b0 <altera_avalon_jtag_uart_write+0x1b8>
  40169c:	e0bffc17 	ldw	r2,-16(fp)
  4016a0:	10c00917 	ldw	r3,36(r2)
  4016a4:	e0bffc17 	ldw	r2,-16(fp)
  4016a8:	10800117 	ldw	r2,4(r2)
  4016ac:	18bff736 	bltu	r3,r2,40168c <__alt_mem_flash_tristate_controller_0+0xfd40168c>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
  4016b0:	e0bffc17 	ldw	r2,-16(fp)
  4016b4:	10800917 	ldw	r2,36(r2)
  4016b8:	10000126 	beq	r2,zero,4016c0 <altera_avalon_jtag_uart_write+0x1c8>
         break;
  4016bc:	00000206 	br	4016c8 <altera_avalon_jtag_uart_write+0x1d0>
    }
  }
  while (count > 0);
  4016c0:	e0bffe17 	ldw	r2,-8(fp)
  4016c4:	00bf9716 	blt	zero,r2,401524 <__alt_mem_flash_tristate_controller_0+0xfd401524>
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
  4016c8:	e0fffd17 	ldw	r3,-12(fp)
  4016cc:	e0bff717 	ldw	r2,-36(fp)
  4016d0:	18800426 	beq	r3,r2,4016e4 <altera_avalon_jtag_uart_write+0x1ec>
    return ptr - start;
  4016d4:	e0fffd17 	ldw	r3,-12(fp)
  4016d8:	e0bff717 	ldw	r2,-36(fp)
  4016dc:	1885c83a 	sub	r2,r3,r2
  4016e0:	00000606 	br	4016fc <altera_avalon_jtag_uart_write+0x204>
  else if (flags & O_NONBLOCK)
  4016e4:	e0bfff17 	ldw	r2,-4(fp)
  4016e8:	1090000c 	andi	r2,r2,16384
  4016ec:	10000226 	beq	r2,zero,4016f8 <altera_avalon_jtag_uart_write+0x200>
    return -EWOULDBLOCK;
  4016f0:	00bffd44 	movi	r2,-11
  4016f4:	00000106 	br	4016fc <altera_avalon_jtag_uart_write+0x204>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
  4016f8:	00bffec4 	movi	r2,-5
}
  4016fc:	e037883a 	mov	sp,fp
  401700:	dfc00117 	ldw	ra,4(sp)
  401704:	df000017 	ldw	fp,0(sp)
  401708:	dec00204 	addi	sp,sp,8
  40170c:	f800283a 	ret

00401710 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
  401710:	defffa04 	addi	sp,sp,-24
  401714:	dfc00515 	stw	ra,20(sp)
  401718:	df000415 	stw	fp,16(sp)
  40171c:	df000404 	addi	fp,sp,16
  401720:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
  401724:	0007883a 	mov	r3,zero
  401728:	e0bfff17 	ldw	r2,-4(fp)
  40172c:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
  401730:	e0bfff17 	ldw	r2,-4(fp)
  401734:	10800104 	addi	r2,r2,4
  401738:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  40173c:	0005303a 	rdctl	r2,status
  401740:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  401744:	e0fffd17 	ldw	r3,-12(fp)
  401748:	00bfff84 	movi	r2,-2
  40174c:	1884703a 	and	r2,r3,r2
  401750:	1001703a 	wrctl	status,r2
  
  return context;
  401754:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
  401758:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
  40175c:	04028a80 	call	4028a8 <alt_tick>
  401760:	e0bffc17 	ldw	r2,-16(fp)
  401764:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  401768:	e0bffe17 	ldw	r2,-8(fp)
  40176c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
  401770:	e037883a 	mov	sp,fp
  401774:	dfc00117 	ldw	ra,4(sp)
  401778:	df000017 	ldw	fp,0(sp)
  40177c:	dec00204 	addi	sp,sp,8
  401780:	f800283a 	ret

00401784 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
  401784:	defff804 	addi	sp,sp,-32
  401788:	dfc00715 	stw	ra,28(sp)
  40178c:	df000615 	stw	fp,24(sp)
  401790:	df000604 	addi	fp,sp,24
  401794:	e13ffc15 	stw	r4,-16(fp)
  401798:	e17ffd15 	stw	r5,-12(fp)
  40179c:	e1bffe15 	stw	r6,-8(fp)
  4017a0:	e1ffff15 	stw	r7,-4(fp)
  4017a4:	e0bfff17 	ldw	r2,-4(fp)
  4017a8:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
  4017ac:	00801034 	movhi	r2,64
  4017b0:	1096c104 	addi	r2,r2,23300
  4017b4:	10800017 	ldw	r2,0(r2)
  4017b8:	1000041e 	bne	r2,zero,4017cc <alt_avalon_timer_sc_init+0x48>
  {
    _alt_tick_rate = nticks;
  4017bc:	00801034 	movhi	r2,64
  4017c0:	1096c104 	addi	r2,r2,23300
  4017c4:	e0fffb17 	ldw	r3,-20(fp)
  4017c8:	10c00015 	stw	r3,0(r2)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
  4017cc:	e0bffc17 	ldw	r2,-16(fp)
  4017d0:	10800104 	addi	r2,r2,4
  4017d4:	00c001c4 	movi	r3,7
  4017d8:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
  4017dc:	d8000015 	stw	zero,0(sp)
  4017e0:	e13ffd17 	ldw	r4,-12(fp)
  4017e4:	e17ffe17 	ldw	r5,-8(fp)
  4017e8:	01801034 	movhi	r6,64
  4017ec:	3185c404 	addi	r6,r6,5904
  4017f0:	e1fffc17 	ldw	r7,-16(fp)
  4017f4:	04025400 	call	402540 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
  4017f8:	e037883a 	mov	sp,fp
  4017fc:	dfc00117 	ldw	ra,4(sp)
  401800:	df000017 	ldw	fp,0(sp)
  401804:	dec00204 	addi	sp,sp,8
  401808:	f800283a 	ret

0040180c <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  40180c:	defffa04 	addi	sp,sp,-24
  401810:	dfc00515 	stw	ra,20(sp)
  401814:	df000415 	stw	fp,16(sp)
  401818:	df000404 	addi	fp,sp,16
  40181c:	e13ffd15 	stw	r4,-12(fp)
  401820:	e17ffe15 	stw	r5,-8(fp)
  401824:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
  401828:	e0bffd17 	ldw	r2,-12(fp)
  40182c:	10800017 	ldw	r2,0(r2)
  401830:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
  401834:	e0bffc17 	ldw	r2,-16(fp)
  401838:	10c00a04 	addi	r3,r2,40
  40183c:	e0bffd17 	ldw	r2,-12(fp)
  401840:	10800217 	ldw	r2,8(r2)
  401844:	1809883a 	mov	r4,r3
  401848:	e17ffe17 	ldw	r5,-8(fp)
  40184c:	e1bfff17 	ldw	r6,-4(fp)
  401850:	100f883a 	mov	r7,r2
  401854:	0401d240 	call	401d24 <altera_avalon_uart_read>
      fd->fd_flags);
}
  401858:	e037883a 	mov	sp,fp
  40185c:	dfc00117 	ldw	ra,4(sp)
  401860:	df000017 	ldw	fp,0(sp)
  401864:	dec00204 	addi	sp,sp,8
  401868:	f800283a 	ret

0040186c <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  40186c:	defffa04 	addi	sp,sp,-24
  401870:	dfc00515 	stw	ra,20(sp)
  401874:	df000415 	stw	fp,16(sp)
  401878:	df000404 	addi	fp,sp,16
  40187c:	e13ffd15 	stw	r4,-12(fp)
  401880:	e17ffe15 	stw	r5,-8(fp)
  401884:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
  401888:	e0bffd17 	ldw	r2,-12(fp)
  40188c:	10800017 	ldw	r2,0(r2)
  401890:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
  401894:	e0bffc17 	ldw	r2,-16(fp)
  401898:	10c00a04 	addi	r3,r2,40
  40189c:	e0bffd17 	ldw	r2,-12(fp)
  4018a0:	10800217 	ldw	r2,8(r2)
  4018a4:	1809883a 	mov	r4,r3
  4018a8:	e17ffe17 	ldw	r5,-8(fp)
  4018ac:	e1bfff17 	ldw	r6,-4(fp)
  4018b0:	100f883a 	mov	r7,r2
  4018b4:	0401f500 	call	401f50 <altera_avalon_uart_write>
      fd->fd_flags);
}
  4018b8:	e037883a 	mov	sp,fp
  4018bc:	dfc00117 	ldw	ra,4(sp)
  4018c0:	df000017 	ldw	fp,0(sp)
  4018c4:	dec00204 	addi	sp,sp,8
  4018c8:	f800283a 	ret

004018cc <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
  4018cc:	defffc04 	addi	sp,sp,-16
  4018d0:	dfc00315 	stw	ra,12(sp)
  4018d4:	df000215 	stw	fp,8(sp)
  4018d8:	df000204 	addi	fp,sp,8
  4018dc:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
  4018e0:	e0bfff17 	ldw	r2,-4(fp)
  4018e4:	10800017 	ldw	r2,0(r2)
  4018e8:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
  4018ec:	e0bffe17 	ldw	r2,-8(fp)
  4018f0:	10c00a04 	addi	r3,r2,40
  4018f4:	e0bfff17 	ldw	r2,-4(fp)
  4018f8:	10800217 	ldw	r2,8(r2)
  4018fc:	1809883a 	mov	r4,r3
  401900:	100b883a 	mov	r5,r2
  401904:	0401c800 	call	401c80 <altera_avalon_uart_close>
}
  401908:	e037883a 	mov	sp,fp
  40190c:	dfc00117 	ldw	ra,4(sp)
  401910:	df000017 	ldw	fp,0(sp)
  401914:	dec00204 	addi	sp,sp,8
  401918:	f800283a 	ret

0040191c <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
  40191c:	defff804 	addi	sp,sp,-32
  401920:	dfc00715 	stw	ra,28(sp)
  401924:	df000615 	stw	fp,24(sp)
  401928:	df000604 	addi	fp,sp,24
  40192c:	e13ffd15 	stw	r4,-12(fp)
  401930:	e17ffe15 	stw	r5,-8(fp)
  401934:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
  401938:	e0bffd17 	ldw	r2,-12(fp)
  40193c:	10800017 	ldw	r2,0(r2)
  401940:	e0bffb15 	stw	r2,-20(fp)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
  401944:	0005883a 	mov	r2,zero
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
  401948:	1000041e 	bne	r2,zero,40195c <altera_avalon_uart_init+0x40>
  40194c:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
  401950:	1000021e 	bne	r2,zero,40195c <altera_avalon_uart_init+0x40>
  401954:	0005883a 	mov	r2,zero
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
  401958:	10000226 	beq	r2,zero,401964 <altera_avalon_uart_init+0x48>
  40195c:	00800044 	movi	r2,1
  401960:	00000106 	br	401968 <altera_avalon_uart_init+0x4c>
  401964:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
  401968:	e0bffc15 	stw	r2,-16(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
  40196c:	e0bffc17 	ldw	r2,-16(fp)
  401970:	10000f1e 	bne	r2,zero,4019b0 <altera_avalon_uart_init+0x94>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
  401974:	e0bffd17 	ldw	r2,-12(fp)
  401978:	00c32004 	movi	r3,3200
  40197c:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
  401980:	e0bffb17 	ldw	r2,-20(fp)
  401984:	10800304 	addi	r2,r2,12
  401988:	e0fffd17 	ldw	r3,-12(fp)
  40198c:	18c00117 	ldw	r3,4(r3)
  401990:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
  401994:	d8000015 	stw	zero,0(sp)
  401998:	e13ffe17 	ldw	r4,-8(fp)
  40199c:	e17fff17 	ldw	r5,-4(fp)
  4019a0:	01801034 	movhi	r6,64
  4019a4:	31867104 	addi	r6,r6,6596
  4019a8:	e1fffd17 	ldw	r7,-12(fp)
  4019ac:	04025400 	call	402540 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
  4019b0:	e037883a 	mov	sp,fp
  4019b4:	dfc00117 	ldw	ra,4(sp)
  4019b8:	df000017 	ldw	fp,0(sp)
  4019bc:	dec00204 	addi	sp,sp,8
  4019c0:	f800283a 	ret

004019c4 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
  4019c4:	defffa04 	addi	sp,sp,-24
  4019c8:	dfc00515 	stw	ra,20(sp)
  4019cc:	df000415 	stw	fp,16(sp)
  4019d0:	df000404 	addi	fp,sp,16
  4019d4:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
  4019d8:	e0bfff17 	ldw	r2,-4(fp)
  4019dc:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
  4019e0:	e0bffc17 	ldw	r2,-16(fp)
  4019e4:	10800017 	ldw	r2,0(r2)
  4019e8:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
  4019ec:	e0bffd17 	ldw	r2,-12(fp)
  4019f0:	10800204 	addi	r2,r2,8
  4019f4:	10800037 	ldwio	r2,0(r2)
  4019f8:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
  4019fc:	e0bffd17 	ldw	r2,-12(fp)
  401a00:	10800204 	addi	r2,r2,8
  401a04:	0007883a 	mov	r3,zero
  401a08:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
  401a0c:	e0bffd17 	ldw	r2,-12(fp)
  401a10:	10800204 	addi	r2,r2,8
  401a14:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
  401a18:	e0bffe17 	ldw	r2,-8(fp)
  401a1c:	1080200c 	andi	r2,r2,128
  401a20:	10000326 	beq	r2,zero,401a30 <altera_avalon_uart_irq+0x6c>
  {
    altera_avalon_uart_rxirq(sp, status);
  401a24:	e13ffc17 	ldw	r4,-16(fp)
  401a28:	e17ffe17 	ldw	r5,-8(fp)
  401a2c:	0401a5c0 	call	401a5c <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
  401a30:	e0bffe17 	ldw	r2,-8(fp)
  401a34:	1081100c 	andi	r2,r2,1088
  401a38:	10000326 	beq	r2,zero,401a48 <altera_avalon_uart_irq+0x84>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
  401a3c:	e13ffc17 	ldw	r4,-16(fp)
  401a40:	e17ffe17 	ldw	r5,-8(fp)
  401a44:	0401b3c0 	call	401b3c <altera_avalon_uart_txirq>
  }
  

}
  401a48:	e037883a 	mov	sp,fp
  401a4c:	dfc00117 	ldw	ra,4(sp)
  401a50:	df000017 	ldw	fp,0(sp)
  401a54:	dec00204 	addi	sp,sp,8
  401a58:	f800283a 	ret

00401a5c <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
  401a5c:	defffc04 	addi	sp,sp,-16
  401a60:	df000315 	stw	fp,12(sp)
  401a64:	df000304 	addi	fp,sp,12
  401a68:	e13ffe15 	stw	r4,-8(fp)
  401a6c:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
  401a70:	e0bfff17 	ldw	r2,-4(fp)
  401a74:	108000cc 	andi	r2,r2,3
  401a78:	10000126 	beq	r2,zero,401a80 <altera_avalon_uart_rxirq+0x24>
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
  401a7c:	00002b06 	br	401b2c <altera_avalon_uart_rxirq+0xd0>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
  401a80:	e0bffe17 	ldw	r2,-8(fp)
  401a84:	10800317 	ldw	r2,12(r2)
  401a88:	e0bffe17 	ldw	r2,-8(fp)
  401a8c:	10800217 	ldw	r2,8(r2)
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
  401a90:	e0bffe17 	ldw	r2,-8(fp)
  401a94:	10800317 	ldw	r2,12(r2)
  401a98:	10800044 	addi	r2,r2,1
  401a9c:	10800fcc 	andi	r2,r2,63
  401aa0:	e0bffd15 	stw	r2,-12(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
  401aa4:	e0bffe17 	ldw	r2,-8(fp)
  401aa8:	10800317 	ldw	r2,12(r2)
  401aac:	e0fffe17 	ldw	r3,-8(fp)
  401ab0:	18c00017 	ldw	r3,0(r3)
  401ab4:	18c00037 	ldwio	r3,0(r3)
  401ab8:	1809883a 	mov	r4,r3
  401abc:	e0fffe17 	ldw	r3,-8(fp)
  401ac0:	1885883a 	add	r2,r3,r2
  401ac4:	10800704 	addi	r2,r2,28
  401ac8:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
  401acc:	e0bffe17 	ldw	r2,-8(fp)
  401ad0:	e0fffd17 	ldw	r3,-12(fp)
  401ad4:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
  401ad8:	e0bffe17 	ldw	r2,-8(fp)
  401adc:	10800317 	ldw	r2,12(r2)
  401ae0:	10800044 	addi	r2,r2,1
  401ae4:	10800fcc 	andi	r2,r2,63
  401ae8:	e0bffd15 	stw	r2,-12(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
  401aec:	e0bffe17 	ldw	r2,-8(fp)
  401af0:	10c00217 	ldw	r3,8(r2)
  401af4:	e0bffd17 	ldw	r2,-12(fp)
  401af8:	18800c1e 	bne	r3,r2,401b2c <altera_avalon_uart_rxirq+0xd0>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  401afc:	e0bffe17 	ldw	r2,-8(fp)
  401b00:	10c00117 	ldw	r3,4(r2)
  401b04:	00bfdfc4 	movi	r2,-129
  401b08:	1886703a 	and	r3,r3,r2
  401b0c:	e0bffe17 	ldw	r2,-8(fp)
  401b10:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  401b14:	e0bffe17 	ldw	r2,-8(fp)
  401b18:	10800017 	ldw	r2,0(r2)
  401b1c:	10800304 	addi	r2,r2,12
  401b20:	e0fffe17 	ldw	r3,-8(fp)
  401b24:	18c00117 	ldw	r3,4(r3)
  401b28:	10c00035 	stwio	r3,0(r2)
  }   
}
  401b2c:	e037883a 	mov	sp,fp
  401b30:	df000017 	ldw	fp,0(sp)
  401b34:	dec00104 	addi	sp,sp,4
  401b38:	f800283a 	ret

00401b3c <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
  401b3c:	defffb04 	addi	sp,sp,-20
  401b40:	df000415 	stw	fp,16(sp)
  401b44:	df000404 	addi	fp,sp,16
  401b48:	e13ffc15 	stw	r4,-16(fp)
  401b4c:	e17ffd15 	stw	r5,-12(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
  401b50:	e0bffc17 	ldw	r2,-16(fp)
  401b54:	10c00417 	ldw	r3,16(r2)
  401b58:	e0bffc17 	ldw	r2,-16(fp)
  401b5c:	10800517 	ldw	r2,20(r2)
  401b60:	18803226 	beq	r3,r2,401c2c <altera_avalon_uart_txirq+0xf0>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
  401b64:	e0bffc17 	ldw	r2,-16(fp)
  401b68:	10800617 	ldw	r2,24(r2)
  401b6c:	1080008c 	andi	r2,r2,2
  401b70:	10000326 	beq	r2,zero,401b80 <altera_avalon_uart_txirq+0x44>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
  401b74:	e0bffd17 	ldw	r2,-12(fp)
  401b78:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
  401b7c:	10001d26 	beq	r2,zero,401bf4 <altera_avalon_uart_txirq+0xb8>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
  401b80:	e0bffc17 	ldw	r2,-16(fp)
  401b84:	10800417 	ldw	r2,16(r2)
  401b88:	e0bffc17 	ldw	r2,-16(fp)
  401b8c:	10800517 	ldw	r2,20(r2)
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
  401b90:	e0bffc17 	ldw	r2,-16(fp)
  401b94:	10800017 	ldw	r2,0(r2)
  401b98:	10800104 	addi	r2,r2,4
  401b9c:	e0fffc17 	ldw	r3,-16(fp)
  401ba0:	18c00417 	ldw	r3,16(r3)
  401ba4:	e13ffc17 	ldw	r4,-16(fp)
  401ba8:	20c7883a 	add	r3,r4,r3
  401bac:	18c01704 	addi	r3,r3,92
  401bb0:	18c00003 	ldbu	r3,0(r3)
  401bb4:	18c03fcc 	andi	r3,r3,255
  401bb8:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
  401bbc:	e0bffc17 	ldw	r2,-16(fp)
  401bc0:	10800417 	ldw	r2,16(r2)
  401bc4:	10800044 	addi	r2,r2,1
  401bc8:	e0fffc17 	ldw	r3,-16(fp)
  401bcc:	18800415 	stw	r2,16(r3)
  401bd0:	10c00fcc 	andi	r3,r2,63
  401bd4:	e0bffc17 	ldw	r2,-16(fp)
  401bd8:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
  401bdc:	e0bffc17 	ldw	r2,-16(fp)
  401be0:	10800117 	ldw	r2,4(r2)
  401be4:	10c01014 	ori	r3,r2,64
  401be8:	e0bffc17 	ldw	r2,-16(fp)
  401bec:	10c00115 	stw	r3,4(r2)
  401bf0:	00000e06 	br	401c2c <altera_avalon_uart_txirq+0xf0>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
  401bf4:	e0bffc17 	ldw	r2,-16(fp)
  401bf8:	10800017 	ldw	r2,0(r2)
  401bfc:	10800204 	addi	r2,r2,8
  401c00:	10800037 	ldwio	r2,0(r2)
  401c04:	e0bffd15 	stw	r2,-12(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
  401c08:	e0bffd17 	ldw	r2,-12(fp)
  401c0c:	1082000c 	andi	r2,r2,2048
  401c10:	1000061e 	bne	r2,zero,401c2c <altera_avalon_uart_txirq+0xf0>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
  401c14:	e0bffc17 	ldw	r2,-16(fp)
  401c18:	10c00117 	ldw	r3,4(r2)
  401c1c:	00bfefc4 	movi	r2,-65
  401c20:	1886703a 	and	r3,r3,r2
  401c24:	e0bffc17 	ldw	r2,-16(fp)
  401c28:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
  401c2c:	e0bffc17 	ldw	r2,-16(fp)
  401c30:	10c00417 	ldw	r3,16(r2)
  401c34:	e0bffc17 	ldw	r2,-16(fp)
  401c38:	10800517 	ldw	r2,20(r2)
  401c3c:	1880061e 	bne	r3,r2,401c58 <altera_avalon_uart_txirq+0x11c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
  401c40:	e0bffc17 	ldw	r2,-16(fp)
  401c44:	10c00117 	ldw	r3,4(r2)
  401c48:	00beefc4 	movi	r2,-1089
  401c4c:	1886703a 	and	r3,r3,r2
  401c50:	e0bffc17 	ldw	r2,-16(fp)
  401c54:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  401c58:	e0bffc17 	ldw	r2,-16(fp)
  401c5c:	10800017 	ldw	r2,0(r2)
  401c60:	10800304 	addi	r2,r2,12
  401c64:	e0fffc17 	ldw	r3,-16(fp)
  401c68:	18c00117 	ldw	r3,4(r3)
  401c6c:	10c00035 	stwio	r3,0(r2)
}
  401c70:	e037883a 	mov	sp,fp
  401c74:	df000017 	ldw	fp,0(sp)
  401c78:	dec00104 	addi	sp,sp,4
  401c7c:	f800283a 	ret

00401c80 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  401c80:	defffd04 	addi	sp,sp,-12
  401c84:	df000215 	stw	fp,8(sp)
  401c88:	df000204 	addi	fp,sp,8
  401c8c:	e13ffe15 	stw	r4,-8(fp)
  401c90:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
  401c94:	00000506 	br	401cac <altera_avalon_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
  401c98:	e0bfff17 	ldw	r2,-4(fp)
  401c9c:	1090000c 	andi	r2,r2,16384
  401ca0:	10000226 	beq	r2,zero,401cac <altera_avalon_uart_close+0x2c>
      return -EWOULDBLOCK; 
  401ca4:	00bffd44 	movi	r2,-11
  401ca8:	00000606 	br	401cc4 <altera_avalon_uart_close+0x44>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
  401cac:	e0bffe17 	ldw	r2,-8(fp)
  401cb0:	10c00417 	ldw	r3,16(r2)
  401cb4:	e0bffe17 	ldw	r2,-8(fp)
  401cb8:	10800517 	ldw	r2,20(r2)
  401cbc:	18bff61e 	bne	r3,r2,401c98 <__alt_mem_flash_tristate_controller_0+0xfd401c98>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
  401cc0:	0005883a 	mov	r2,zero
}
  401cc4:	e037883a 	mov	sp,fp
  401cc8:	df000017 	ldw	fp,0(sp)
  401ccc:	dec00104 	addi	sp,sp,4
  401cd0:	f800283a 	ret

00401cd4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  401cd4:	defffe04 	addi	sp,sp,-8
  401cd8:	dfc00115 	stw	ra,4(sp)
  401cdc:	df000015 	stw	fp,0(sp)
  401ce0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  401ce4:	00801034 	movhi	r2,64
  401ce8:	1090c204 	addi	r2,r2,17160
  401cec:	10800017 	ldw	r2,0(r2)
  401cf0:	10000526 	beq	r2,zero,401d08 <alt_get_errno+0x34>
  401cf4:	00801034 	movhi	r2,64
  401cf8:	1090c204 	addi	r2,r2,17160
  401cfc:	10800017 	ldw	r2,0(r2)
  401d00:	103ee83a 	callr	r2
  401d04:	00000206 	br	401d10 <alt_get_errno+0x3c>
  401d08:	00801034 	movhi	r2,64
  401d0c:	1096c304 	addi	r2,r2,23308
}
  401d10:	e037883a 	mov	sp,fp
  401d14:	dfc00117 	ldw	ra,4(sp)
  401d18:	df000017 	ldw	fp,0(sp)
  401d1c:	dec00204 	addi	sp,sp,8
  401d20:	f800283a 	ret

00401d24 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
  401d24:	defff204 	addi	sp,sp,-56
  401d28:	dfc00d15 	stw	ra,52(sp)
  401d2c:	df000c15 	stw	fp,48(sp)
  401d30:	df000c04 	addi	fp,sp,48
  401d34:	e13ffc15 	stw	r4,-16(fp)
  401d38:	e17ffd15 	stw	r5,-12(fp)
  401d3c:	e1bffe15 	stw	r6,-8(fp)
  401d40:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
  401d44:	e03ff405 	stb	zero,-48(fp)
  int             count = 0;
  401d48:	e03ff515 	stw	zero,-44(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
  401d4c:	e0bfff17 	ldw	r2,-4(fp)
  401d50:	1090000c 	andi	r2,r2,16384
  401d54:	1005003a 	cmpeq	r2,r2,zero
  401d58:	10803fcc 	andi	r2,r2,255
  401d5c:	e0bff615 	stw	r2,-40(fp)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
  401d60:	00001306 	br	401db0 <altera_avalon_uart_read+0x8c>
    {
      count++;
  401d64:	e0bff517 	ldw	r2,-44(fp)
  401d68:	10800044 	addi	r2,r2,1
  401d6c:	e0bff515 	stw	r2,-44(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
  401d70:	e0bffd17 	ldw	r2,-12(fp)
  401d74:	10c00044 	addi	r3,r2,1
  401d78:	e0fffd15 	stw	r3,-12(fp)
  401d7c:	e0fffc17 	ldw	r3,-16(fp)
  401d80:	18c00217 	ldw	r3,8(r3)
  401d84:	e13ffc17 	ldw	r4,-16(fp)
  401d88:	20c7883a 	add	r3,r4,r3
  401d8c:	18c00704 	addi	r3,r3,28
  401d90:	18c00003 	ldbu	r3,0(r3)
  401d94:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
  401d98:	e0bffc17 	ldw	r2,-16(fp)
  401d9c:	10800217 	ldw	r2,8(r2)
  401da0:	10800044 	addi	r2,r2,1
  401da4:	10c00fcc 	andi	r3,r2,63
  401da8:	e0bffc17 	ldw	r2,-16(fp)
  401dac:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
  401db0:	e0fff517 	ldw	r3,-44(fp)
  401db4:	e0bffe17 	ldw	r2,-8(fp)
  401db8:	1880050e 	bge	r3,r2,401dd0 <altera_avalon_uart_read+0xac>
  401dbc:	e0bffc17 	ldw	r2,-16(fp)
  401dc0:	10c00217 	ldw	r3,8(r2)
  401dc4:	e0bffc17 	ldw	r2,-16(fp)
  401dc8:	10800317 	ldw	r2,12(r2)
  401dcc:	18bfe51e 	bne	r3,r2,401d64 <__alt_mem_flash_tristate_controller_0+0xfd401d64>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
  401dd0:	e0bff517 	ldw	r2,-44(fp)
  401dd4:	1000251e 	bne	r2,zero,401e6c <altera_avalon_uart_read+0x148>
  401dd8:	e0bffc17 	ldw	r2,-16(fp)
  401ddc:	10c00217 	ldw	r3,8(r2)
  401de0:	e0bffc17 	ldw	r2,-16(fp)
  401de4:	10800317 	ldw	r2,12(r2)
  401de8:	1880201e 	bne	r3,r2,401e6c <altera_avalon_uart_read+0x148>
    {
      if (!block)
  401dec:	e0bff617 	ldw	r2,-40(fp)
  401df0:	1000071e 	bne	r2,zero,401e10 <altera_avalon_uart_read+0xec>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
  401df4:	0401cd40 	call	401cd4 <alt_get_errno>
  401df8:	1007883a 	mov	r3,r2
  401dfc:	008002c4 	movi	r2,11
  401e00:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
  401e04:	00800044 	movi	r2,1
  401e08:	e0bff405 	stb	r2,-48(fp)
        break;
  401e0c:	00001b06 	br	401e7c <altera_avalon_uart_read+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  401e10:	0005303a 	rdctl	r2,status
  401e14:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  401e18:	e0fff817 	ldw	r3,-32(fp)
  401e1c:	00bfff84 	movi	r2,-2
  401e20:	1884703a 	and	r2,r3,r2
  401e24:	1001703a 	wrctl	status,r2
  
  return context;
  401e28:	e0bff817 	ldw	r2,-32(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
  401e2c:	e0bff715 	stw	r2,-36(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  401e30:	e0bffc17 	ldw	r2,-16(fp)
  401e34:	10800117 	ldw	r2,4(r2)
  401e38:	10c02014 	ori	r3,r2,128
  401e3c:	e0bffc17 	ldw	r2,-16(fp)
  401e40:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  401e44:	e0bffc17 	ldw	r2,-16(fp)
  401e48:	10800017 	ldw	r2,0(r2)
  401e4c:	10800304 	addi	r2,r2,12
  401e50:	e0fffc17 	ldw	r3,-16(fp)
  401e54:	18c00117 	ldw	r3,4(r3)
  401e58:	10c00035 	stwio	r3,0(r2)
  401e5c:	e0bff717 	ldw	r2,-36(fp)
  401e60:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  401e64:	e0bff917 	ldw	r2,-28(fp)
  401e68:	1001703a 	wrctl	status,r2
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
  401e6c:	e0bff517 	ldw	r2,-44(fp)
  401e70:	1000021e 	bne	r2,zero,401e7c <altera_avalon_uart_read+0x158>
  401e74:	e0bffe17 	ldw	r2,-8(fp)
  401e78:	103fb91e 	bne	r2,zero,401d60 <__alt_mem_flash_tristate_controller_0+0xfd401d60>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  401e7c:	0005303a 	rdctl	r2,status
  401e80:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  401e84:	e0fffa17 	ldw	r3,-24(fp)
  401e88:	00bfff84 	movi	r2,-2
  401e8c:	1884703a 	and	r2,r3,r2
  401e90:	1001703a 	wrctl	status,r2
  
  return context;
  401e94:	e0bffa17 	ldw	r2,-24(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
  401e98:	e0bff715 	stw	r2,-36(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  401e9c:	e0bffc17 	ldw	r2,-16(fp)
  401ea0:	10800117 	ldw	r2,4(r2)
  401ea4:	10c02014 	ori	r3,r2,128
  401ea8:	e0bffc17 	ldw	r2,-16(fp)
  401eac:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  401eb0:	e0bffc17 	ldw	r2,-16(fp)
  401eb4:	10800017 	ldw	r2,0(r2)
  401eb8:	10800304 	addi	r2,r2,12
  401ebc:	e0fffc17 	ldw	r3,-16(fp)
  401ec0:	18c00117 	ldw	r3,4(r3)
  401ec4:	10c00035 	stwio	r3,0(r2)
  401ec8:	e0bff717 	ldw	r2,-36(fp)
  401ecc:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  401ed0:	e0bffb17 	ldw	r2,-20(fp)
  401ed4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
  401ed8:	e0bff403 	ldbu	r2,-48(fp)
  401edc:	10000226 	beq	r2,zero,401ee8 <altera_avalon_uart_read+0x1c4>
    return -EWOULDBLOCK;
  401ee0:	00bffd44 	movi	r2,-11
  401ee4:	00000106 	br	401eec <altera_avalon_uart_read+0x1c8>
  }
  else {
    return count;
  401ee8:	e0bff517 	ldw	r2,-44(fp)
  }
}
  401eec:	e037883a 	mov	sp,fp
  401ef0:	dfc00117 	ldw	ra,4(sp)
  401ef4:	df000017 	ldw	fp,0(sp)
  401ef8:	dec00204 	addi	sp,sp,8
  401efc:	f800283a 	ret

00401f00 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  401f00:	defffe04 	addi	sp,sp,-8
  401f04:	dfc00115 	stw	ra,4(sp)
  401f08:	df000015 	stw	fp,0(sp)
  401f0c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  401f10:	00801034 	movhi	r2,64
  401f14:	1090c204 	addi	r2,r2,17160
  401f18:	10800017 	ldw	r2,0(r2)
  401f1c:	10000526 	beq	r2,zero,401f34 <alt_get_errno+0x34>
  401f20:	00801034 	movhi	r2,64
  401f24:	1090c204 	addi	r2,r2,17160
  401f28:	10800017 	ldw	r2,0(r2)
  401f2c:	103ee83a 	callr	r2
  401f30:	00000206 	br	401f3c <alt_get_errno+0x3c>
  401f34:	00801034 	movhi	r2,64
  401f38:	1096c304 	addi	r2,r2,23308
}
  401f3c:	e037883a 	mov	sp,fp
  401f40:	dfc00117 	ldw	ra,4(sp)
  401f44:	df000017 	ldw	fp,0(sp)
  401f48:	dec00204 	addi	sp,sp,8
  401f4c:	f800283a 	ret

00401f50 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
  401f50:	defff204 	addi	sp,sp,-56
  401f54:	dfc00d15 	stw	ra,52(sp)
  401f58:	df000c15 	stw	fp,48(sp)
  401f5c:	df000c04 	addi	fp,sp,48
  401f60:	e13ffc15 	stw	r4,-16(fp)
  401f64:	e17ffd15 	stw	r5,-12(fp)
  401f68:	e1bffe15 	stw	r6,-8(fp)
  401f6c:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
  401f70:	e0bffe17 	ldw	r2,-8(fp)
  401f74:	e0bff415 	stw	r2,-48(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
  401f78:	e0bfff17 	ldw	r2,-4(fp)
  401f7c:	1090000c 	andi	r2,r2,16384
  401f80:	e0bff515 	stw	r2,-44(fp)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
  401f84:	00003c06 	br	402078 <altera_avalon_uart_write+0x128>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
  401f88:	e0bffc17 	ldw	r2,-16(fp)
  401f8c:	10800517 	ldw	r2,20(r2)
  401f90:	10800044 	addi	r2,r2,1
  401f94:	10800fcc 	andi	r2,r2,63
  401f98:	e0bff615 	stw	r2,-40(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
  401f9c:	e0bffc17 	ldw	r2,-16(fp)
  401fa0:	10c00417 	ldw	r3,16(r2)
  401fa4:	e0bff617 	ldw	r2,-40(fp)
  401fa8:	1880221e 	bne	r3,r2,402034 <altera_avalon_uart_write+0xe4>
    {
      if (no_block)
  401fac:	e0bff517 	ldw	r2,-44(fp)
  401fb0:	10000526 	beq	r2,zero,401fc8 <altera_avalon_uart_write+0x78>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
  401fb4:	0401f000 	call	401f00 <alt_get_errno>
  401fb8:	1007883a 	mov	r3,r2
  401fbc:	008002c4 	movi	r2,11
  401fc0:	18800015 	stw	r2,0(r3)
        break;
  401fc4:	00002e06 	br	402080 <altera_avalon_uart_write+0x130>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  401fc8:	0005303a 	rdctl	r2,status
  401fcc:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  401fd0:	e0fff817 	ldw	r3,-32(fp)
  401fd4:	00bfff84 	movi	r2,-2
  401fd8:	1884703a 	and	r2,r3,r2
  401fdc:	1001703a 	wrctl	status,r2
  
  return context;
  401fe0:	e0bff817 	ldw	r2,-32(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
  401fe4:	e0bff715 	stw	r2,-36(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
  401fe8:	e0bffc17 	ldw	r2,-16(fp)
  401fec:	10800117 	ldw	r2,4(r2)
  401ff0:	10c11014 	ori	r3,r2,1088
  401ff4:	e0bffc17 	ldw	r2,-16(fp)
  401ff8:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  401ffc:	e0bffc17 	ldw	r2,-16(fp)
  402000:	10800017 	ldw	r2,0(r2)
  402004:	10800304 	addi	r2,r2,12
  402008:	e0fffc17 	ldw	r3,-16(fp)
  40200c:	18c00117 	ldw	r3,4(r3)
  402010:	10c00035 	stwio	r3,0(r2)
  402014:	e0bff717 	ldw	r2,-36(fp)
  402018:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  40201c:	e0bff917 	ldw	r2,-28(fp)
  402020:	1001703a 	wrctl	status,r2
          ALT_FLAG_PEND (sp->events, 
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
  402024:	e0bffc17 	ldw	r2,-16(fp)
  402028:	10c00417 	ldw	r3,16(r2)
  40202c:	e0bff617 	ldw	r2,-40(fp)
  402030:	18bffc26 	beq	r3,r2,402024 <__alt_mem_flash_tristate_controller_0+0xfd402024>
      }
    }

    count--;
  402034:	e0bff417 	ldw	r2,-48(fp)
  402038:	10bfffc4 	addi	r2,r2,-1
  40203c:	e0bff415 	stw	r2,-48(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
  402040:	e0bffc17 	ldw	r2,-16(fp)
  402044:	10c00517 	ldw	r3,20(r2)
  402048:	e0bffd17 	ldw	r2,-12(fp)
  40204c:	11000044 	addi	r4,r2,1
  402050:	e13ffd15 	stw	r4,-12(fp)
  402054:	10800003 	ldbu	r2,0(r2)
  402058:	1009883a 	mov	r4,r2
  40205c:	e0bffc17 	ldw	r2,-16(fp)
  402060:	10c5883a 	add	r2,r2,r3
  402064:	10801704 	addi	r2,r2,92
  402068:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
  40206c:	e0bffc17 	ldw	r2,-16(fp)
  402070:	e0fff617 	ldw	r3,-40(fp)
  402074:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
  402078:	e0bff417 	ldw	r2,-48(fp)
  40207c:	103fc21e 	bne	r2,zero,401f88 <__alt_mem_flash_tristate_controller_0+0xfd401f88>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  402080:	0005303a 	rdctl	r2,status
  402084:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  402088:	e0fffa17 	ldw	r3,-24(fp)
  40208c:	00bfff84 	movi	r2,-2
  402090:	1884703a 	and	r2,r3,r2
  402094:	1001703a 	wrctl	status,r2
  
  return context;
  402098:	e0bffa17 	ldw	r2,-24(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
  40209c:	e0bff715 	stw	r2,-36(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
  4020a0:	e0bffc17 	ldw	r2,-16(fp)
  4020a4:	10800117 	ldw	r2,4(r2)
  4020a8:	10c11014 	ori	r3,r2,1088
  4020ac:	e0bffc17 	ldw	r2,-16(fp)
  4020b0:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  4020b4:	e0bffc17 	ldw	r2,-16(fp)
  4020b8:	10800017 	ldw	r2,0(r2)
  4020bc:	10800304 	addi	r2,r2,12
  4020c0:	e0fffc17 	ldw	r3,-16(fp)
  4020c4:	18c00117 	ldw	r3,4(r3)
  4020c8:	10c00035 	stwio	r3,0(r2)
  4020cc:	e0bff717 	ldw	r2,-36(fp)
  4020d0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  4020d4:	e0bffb17 	ldw	r2,-20(fp)
  4020d8:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
  4020dc:	e0fffe17 	ldw	r3,-8(fp)
  4020e0:	e0bff417 	ldw	r2,-48(fp)
  4020e4:	1885c83a 	sub	r2,r3,r2
}
  4020e8:	e037883a 	mov	sp,fp
  4020ec:	dfc00117 	ldw	ra,4(sp)
  4020f0:	df000017 	ldw	fp,0(sp)
  4020f4:	dec00204 	addi	sp,sp,8
  4020f8:	f800283a 	ret

004020fc <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
  4020fc:	defff504 	addi	sp,sp,-44
  402100:	df000a15 	stw	fp,40(sp)
  402104:	df000a04 	addi	fp,sp,40
  402108:	e13ffc15 	stw	r4,-16(fp)
  40210c:	e17ffd15 	stw	r5,-12(fp)
  402110:	e1bffe15 	stw	r6,-8(fp)
  402114:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
  402118:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
  40211c:	00801034 	movhi	r2,64
  402120:	1096c104 	addi	r2,r2,23300
  402124:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
  402128:	10003f26 	beq	r2,zero,402228 <alt_alarm_start+0x12c>
  {
    if (alarm)
  40212c:	e0bffc17 	ldw	r2,-16(fp)
  402130:	10003b26 	beq	r2,zero,402220 <alt_alarm_start+0x124>
    {
      alarm->callback = callback;
  402134:	e0bffc17 	ldw	r2,-16(fp)
  402138:	e0fffe17 	ldw	r3,-8(fp)
  40213c:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
  402140:	e0bffc17 	ldw	r2,-16(fp)
  402144:	e0ffff17 	ldw	r3,-4(fp)
  402148:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  40214c:	0005303a 	rdctl	r2,status
  402150:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  402154:	e0fff817 	ldw	r3,-32(fp)
  402158:	00bfff84 	movi	r2,-2
  40215c:	1884703a 	and	r2,r3,r2
  402160:	1001703a 	wrctl	status,r2
  
  return context;
  402164:	e0bff817 	ldw	r2,-32(fp)
 
      irq_context = alt_irq_disable_all ();
  402168:	e0bff715 	stw	r2,-36(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
  40216c:	00801034 	movhi	r2,64
  402170:	1096c204 	addi	r2,r2,23304
  402174:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
  402178:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
  40217c:	e0fffd17 	ldw	r3,-12(fp)
  402180:	e0bff617 	ldw	r2,-40(fp)
  402184:	1885883a 	add	r2,r3,r2
  402188:	10c00044 	addi	r3,r2,1
  40218c:	e0bffc17 	ldw	r2,-16(fp)
  402190:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
  402194:	e0bffc17 	ldw	r2,-16(fp)
  402198:	10c00217 	ldw	r3,8(r2)
  40219c:	e0bff617 	ldw	r2,-40(fp)
  4021a0:	1880042e 	bgeu	r3,r2,4021b4 <alt_alarm_start+0xb8>
      {
        alarm->rollover = 1;
  4021a4:	e0bffc17 	ldw	r2,-16(fp)
  4021a8:	00c00044 	movi	r3,1
  4021ac:	10c00405 	stb	r3,16(r2)
  4021b0:	00000206 	br	4021bc <alt_alarm_start+0xc0>
      }
      else
      {
        alarm->rollover = 0;
  4021b4:	e0bffc17 	ldw	r2,-16(fp)
  4021b8:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
  4021bc:	e0fffc17 	ldw	r3,-16(fp)
  4021c0:	00801034 	movhi	r2,64
  4021c4:	1090c404 	addi	r2,r2,17168
  4021c8:	e0bff915 	stw	r2,-28(fp)
  4021cc:	e0fffa15 	stw	r3,-24(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  4021d0:	e0bffa17 	ldw	r2,-24(fp)
  4021d4:	e0fff917 	ldw	r3,-28(fp)
  4021d8:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  4021dc:	e0bff917 	ldw	r2,-28(fp)
  4021e0:	10c00017 	ldw	r3,0(r2)
  4021e4:	e0bffa17 	ldw	r2,-24(fp)
  4021e8:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  4021ec:	e0bff917 	ldw	r2,-28(fp)
  4021f0:	10800017 	ldw	r2,0(r2)
  4021f4:	e0fffa17 	ldw	r3,-24(fp)
  4021f8:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  4021fc:	e0bff917 	ldw	r2,-28(fp)
  402200:	e0fffa17 	ldw	r3,-24(fp)
  402204:	10c00015 	stw	r3,0(r2)
  402208:	e0bff717 	ldw	r2,-36(fp)
  40220c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  402210:	e0bffb17 	ldw	r2,-20(fp)
  402214:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
  402218:	0005883a 	mov	r2,zero
  40221c:	00000306 	br	40222c <alt_alarm_start+0x130>
    }
    else
    {
      return -EINVAL;
  402220:	00bffa84 	movi	r2,-22
  402224:	00000106 	br	40222c <alt_alarm_start+0x130>
    }
  }
  else
  {
    return -ENOTSUP;
  402228:	00bfde84 	movi	r2,-134
  }
}
  40222c:	e037883a 	mov	sp,fp
  402230:	df000017 	ldw	fp,0(sp)
  402234:	dec00104 	addi	sp,sp,4
  402238:	f800283a 	ret

0040223c <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
  40223c:	defffa04 	addi	sp,sp,-24
  402240:	dfc00515 	stw	ra,20(sp)
  402244:	df000415 	stw	fp,16(sp)
  402248:	df000404 	addi	fp,sp,16
  40224c:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
  402250:	008000c4 	movi	r2,3
  402254:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
  402258:	e0fffd17 	ldw	r3,-12(fp)
  40225c:	008003f4 	movhi	r2,15
  402260:	10909004 	addi	r2,r2,16960
  402264:	1885383a 	mul	r2,r3,r2
  402268:	0100bef4 	movhi	r4,763
  40226c:	213c2004 	addi	r4,r4,-3968
  402270:	100b883a 	mov	r5,r2
  402274:	0402ae80 	call	402ae8 <__udivsi3>
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
  402278:	01200034 	movhi	r4,32768
  40227c:	213fffc4 	addi	r4,r4,-1
  402280:	100b883a 	mov	r5,r2
  402284:	0402ae80 	call	402ae8 <__udivsi3>
  402288:	e13fff17 	ldw	r4,-4(fp)
  40228c:	100b883a 	mov	r5,r2
  402290:	0402ae80 	call	402ae8 <__udivsi3>
  402294:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  402298:	e0bffe17 	ldw	r2,-8(fp)
  40229c:	10002a26 	beq	r2,zero,402348 <alt_busy_sleep+0x10c>
  {
    for(i=0;i<big_loops;i++)
  4022a0:	e03ffc15 	stw	zero,-16(fp)
  4022a4:	00001706 	br	402304 <alt_busy_sleep+0xc8>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
  4022a8:	00a00034 	movhi	r2,32768
  4022ac:	10bfffc4 	addi	r2,r2,-1
  4022b0:	10bfffc4 	addi	r2,r2,-1
  4022b4:	103ffe1e 	bne	r2,zero,4022b0 <__alt_mem_flash_tristate_controller_0+0xfd4022b0>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
  4022b8:	e0fffd17 	ldw	r3,-12(fp)
  4022bc:	008003f4 	movhi	r2,15
  4022c0:	10909004 	addi	r2,r2,16960
  4022c4:	1885383a 	mul	r2,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
  4022c8:	0100bef4 	movhi	r4,763
  4022cc:	213c2004 	addi	r4,r4,-3968
  4022d0:	100b883a 	mov	r5,r2
  4022d4:	0402ae80 	call	402ae8 <__udivsi3>
  4022d8:	01200034 	movhi	r4,32768
  4022dc:	213fffc4 	addi	r4,r4,-1
  4022e0:	100b883a 	mov	r5,r2
  4022e4:	0402ae80 	call	402ae8 <__udivsi3>
  4022e8:	1007883a 	mov	r3,r2
  4022ec:	e0bfff17 	ldw	r2,-4(fp)
  4022f0:	10c5c83a 	sub	r2,r2,r3
  4022f4:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
  4022f8:	e0bffc17 	ldw	r2,-16(fp)
  4022fc:	10800044 	addi	r2,r2,1
  402300:	e0bffc15 	stw	r2,-16(fp)
  402304:	e0fffc17 	ldw	r3,-16(fp)
  402308:	e0bffe17 	ldw	r2,-8(fp)
  40230c:	18bfe616 	blt	r3,r2,4022a8 <__alt_mem_flash_tristate_controller_0+0xfd4022a8>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  402310:	e0fffd17 	ldw	r3,-12(fp)
  402314:	008003f4 	movhi	r2,15
  402318:	10909004 	addi	r2,r2,16960
  40231c:	1885383a 	mul	r2,r3,r2
  402320:	0100bef4 	movhi	r4,763
  402324:	213c2004 	addi	r4,r4,-3968
  402328:	100b883a 	mov	r5,r2
  40232c:	0402ae80 	call	402ae8 <__udivsi3>
  402330:	1007883a 	mov	r3,r2
  402334:	e0bfff17 	ldw	r2,-4(fp)
  402338:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
  40233c:	10bfffc4 	addi	r2,r2,-1
  402340:	103ffe1e 	bne	r2,zero,40233c <__alt_mem_flash_tristate_controller_0+0xfd40233c>
  402344:	00000d06 	br	40237c <alt_busy_sleep+0x140>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  402348:	e0fffd17 	ldw	r3,-12(fp)
  40234c:	008003f4 	movhi	r2,15
  402350:	10909004 	addi	r2,r2,16960
  402354:	1885383a 	mul	r2,r3,r2
  402358:	0100bef4 	movhi	r4,763
  40235c:	213c2004 	addi	r4,r4,-3968
  402360:	100b883a 	mov	r5,r2
  402364:	0402ae80 	call	402ae8 <__udivsi3>
  402368:	1007883a 	mov	r3,r2
  40236c:	e0bfff17 	ldw	r2,-4(fp)
  402370:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
  402374:	10bfffc4 	addi	r2,r2,-1
  402378:	00bffe16 	blt	zero,r2,402374 <__alt_mem_flash_tristate_controller_0+0xfd402374>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
  40237c:	0005883a 	mov	r2,zero
}
  402380:	e037883a 	mov	sp,fp
  402384:	dfc00117 	ldw	ra,4(sp)
  402388:	df000017 	ldw	fp,0(sp)
  40238c:	dec00204 	addi	sp,sp,8
  402390:	f800283a 	ret

00402394 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  402394:	defffc04 	addi	sp,sp,-16
  402398:	df000315 	stw	fp,12(sp)
  40239c:	df000304 	addi	fp,sp,12
  4023a0:	e13ffd15 	stw	r4,-12(fp)
  4023a4:	e17ffe15 	stw	r5,-8(fp)
  4023a8:	e1bfff15 	stw	r6,-4(fp)
  return len;
  4023ac:	e0bfff17 	ldw	r2,-4(fp)
}
  4023b0:	e037883a 	mov	sp,fp
  4023b4:	df000017 	ldw	fp,0(sp)
  4023b8:	dec00104 	addi	sp,sp,4
  4023bc:	f800283a 	ret

004023c0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  4023c0:	defffe04 	addi	sp,sp,-8
  4023c4:	dfc00115 	stw	ra,4(sp)
  4023c8:	df000015 	stw	fp,0(sp)
  4023cc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  4023d0:	00801034 	movhi	r2,64
  4023d4:	1090c204 	addi	r2,r2,17160
  4023d8:	10800017 	ldw	r2,0(r2)
  4023dc:	10000526 	beq	r2,zero,4023f4 <alt_get_errno+0x34>
  4023e0:	00801034 	movhi	r2,64
  4023e4:	1090c204 	addi	r2,r2,17160
  4023e8:	10800017 	ldw	r2,0(r2)
  4023ec:	103ee83a 	callr	r2
  4023f0:	00000206 	br	4023fc <alt_get_errno+0x3c>
  4023f4:	00801034 	movhi	r2,64
  4023f8:	1096c304 	addi	r2,r2,23308
}
  4023fc:	e037883a 	mov	sp,fp
  402400:	dfc00117 	ldw	ra,4(sp)
  402404:	df000017 	ldw	fp,0(sp)
  402408:	dec00204 	addi	sp,sp,8
  40240c:	f800283a 	ret

00402410 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
  402410:	defffa04 	addi	sp,sp,-24
  402414:	dfc00515 	stw	ra,20(sp)
  402418:	df000415 	stw	fp,16(sp)
  40241c:	df000404 	addi	fp,sp,16
  402420:	e13ffe15 	stw	r4,-8(fp)
  402424:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  402428:	e0bffe17 	ldw	r2,-8(fp)
  40242c:	10000326 	beq	r2,zero,40243c <alt_dev_llist_insert+0x2c>
  402430:	e0bffe17 	ldw	r2,-8(fp)
  402434:	10800217 	ldw	r2,8(r2)
  402438:	1000061e 	bne	r2,zero,402454 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
  40243c:	04023c00 	call	4023c0 <alt_get_errno>
  402440:	1007883a 	mov	r3,r2
  402444:	00800584 	movi	r2,22
  402448:	18800015 	stw	r2,0(r3)
    return -EINVAL;
  40244c:	00bffa84 	movi	r2,-22
  402450:	00001306 	br	4024a0 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
  402454:	e0bffe17 	ldw	r2,-8(fp)
  402458:	e0ffff17 	ldw	r3,-4(fp)
  40245c:	e0fffc15 	stw	r3,-16(fp)
  402460:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  402464:	e0bffd17 	ldw	r2,-12(fp)
  402468:	e0fffc17 	ldw	r3,-16(fp)
  40246c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  402470:	e0bffc17 	ldw	r2,-16(fp)
  402474:	10c00017 	ldw	r3,0(r2)
  402478:	e0bffd17 	ldw	r2,-12(fp)
  40247c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  402480:	e0bffc17 	ldw	r2,-16(fp)
  402484:	10800017 	ldw	r2,0(r2)
  402488:	e0fffd17 	ldw	r3,-12(fp)
  40248c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  402490:	e0bffc17 	ldw	r2,-16(fp)
  402494:	e0fffd17 	ldw	r3,-12(fp)
  402498:	10c00015 	stw	r3,0(r2)

  return 0;  
  40249c:	0005883a 	mov	r2,zero
}
  4024a0:	e037883a 	mov	sp,fp
  4024a4:	dfc00117 	ldw	ra,4(sp)
  4024a8:	df000017 	ldw	fp,0(sp)
  4024ac:	dec00204 	addi	sp,sp,8
  4024b0:	f800283a 	ret

004024b4 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
  4024b4:	defffb04 	addi	sp,sp,-20
  4024b8:	df000415 	stw	fp,16(sp)
  4024bc:	df000404 	addi	fp,sp,16
  4024c0:	e13ffe15 	stw	r4,-8(fp)
  4024c4:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
  4024c8:	e0bfff17 	ldw	r2,-4(fp)
  4024cc:	10840070 	cmpltui	r2,r2,4097
  4024d0:	1000021e 	bne	r2,zero,4024dc <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
  4024d4:	00840004 	movi	r2,4096
  4024d8:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
  4024dc:	e0fffe17 	ldw	r3,-8(fp)
  4024e0:	e0bfff17 	ldw	r2,-4(fp)
  4024e4:	1885883a 	add	r2,r3,r2
  4024e8:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
  4024ec:	e0bffe17 	ldw	r2,-8(fp)
  4024f0:	e0bffc15 	stw	r2,-16(fp)
  4024f4:	00000506 	br	40250c <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
  4024f8:	e0bffc17 	ldw	r2,-16(fp)
  4024fc:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
  402500:	e0bffc17 	ldw	r2,-16(fp)
  402504:	10800804 	addi	r2,r2,32
  402508:	e0bffc15 	stw	r2,-16(fp)
  40250c:	e0fffc17 	ldw	r3,-16(fp)
  402510:	e0bffd17 	ldw	r2,-12(fp)
  402514:	18bff836 	bltu	r3,r2,4024f8 <__alt_mem_flash_tristate_controller_0+0xfd4024f8>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
  402518:	e0bffe17 	ldw	r2,-8(fp)
  40251c:	108007cc 	andi	r2,r2,31
  402520:	10000226 	beq	r2,zero,40252c <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
  402524:	e0bffc17 	ldw	r2,-16(fp)
  402528:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
  40252c:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
  402530:	e037883a 	mov	sp,fp
  402534:	df000017 	ldw	fp,0(sp)
  402538:	dec00104 	addi	sp,sp,4
  40253c:	f800283a 	ret

00402540 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  402540:	defff904 	addi	sp,sp,-28
  402544:	dfc00615 	stw	ra,24(sp)
  402548:	df000515 	stw	fp,20(sp)
  40254c:	df000504 	addi	fp,sp,20
  402550:	e13ffc15 	stw	r4,-16(fp)
  402554:	e17ffd15 	stw	r5,-12(fp)
  402558:	e1bffe15 	stw	r6,-8(fp)
  40255c:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
  402560:	e0800217 	ldw	r2,8(fp)
  402564:	d8800015 	stw	r2,0(sp)
  402568:	e13ffc17 	ldw	r4,-16(fp)
  40256c:	e17ffd17 	ldw	r5,-12(fp)
  402570:	e1bffe17 	ldw	r6,-8(fp)
  402574:	e1ffff17 	ldw	r7,-4(fp)
  402578:	04027200 	call	402720 <alt_iic_isr_register>
}  
  40257c:	e037883a 	mov	sp,fp
  402580:	dfc00117 	ldw	ra,4(sp)
  402584:	df000017 	ldw	fp,0(sp)
  402588:	dec00204 	addi	sp,sp,8
  40258c:	f800283a 	ret

00402590 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
  402590:	defff904 	addi	sp,sp,-28
  402594:	df000615 	stw	fp,24(sp)
  402598:	df000604 	addi	fp,sp,24
  40259c:	e13ffe15 	stw	r4,-8(fp)
  4025a0:	e17fff15 	stw	r5,-4(fp)
  4025a4:	e0bfff17 	ldw	r2,-4(fp)
  4025a8:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  4025ac:	0005303a 	rdctl	r2,status
  4025b0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  4025b4:	e0fffb17 	ldw	r3,-20(fp)
  4025b8:	00bfff84 	movi	r2,-2
  4025bc:	1884703a 	and	r2,r3,r2
  4025c0:	1001703a 	wrctl	status,r2
  
  return context;
  4025c4:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  4025c8:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
  4025cc:	e0bffa17 	ldw	r2,-24(fp)
  4025d0:	00c00044 	movi	r3,1
  4025d4:	1884983a 	sll	r2,r3,r2
  4025d8:	1007883a 	mov	r3,r2
  4025dc:	00801034 	movhi	r2,64
  4025e0:	1096c004 	addi	r2,r2,23296
  4025e4:	10800017 	ldw	r2,0(r2)
  4025e8:	1886b03a 	or	r3,r3,r2
  4025ec:	00801034 	movhi	r2,64
  4025f0:	1096c004 	addi	r2,r2,23296
  4025f4:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  4025f8:	00801034 	movhi	r2,64
  4025fc:	1096c004 	addi	r2,r2,23296
  402600:	10800017 	ldw	r2,0(r2)
  402604:	100170fa 	wrctl	ienable,r2
  402608:	e0bffc17 	ldw	r2,-16(fp)
  40260c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  402610:	e0bffd17 	ldw	r2,-12(fp)
  402614:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  402618:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
  40261c:	0001883a 	nop
}
  402620:	e037883a 	mov	sp,fp
  402624:	df000017 	ldw	fp,0(sp)
  402628:	dec00104 	addi	sp,sp,4
  40262c:	f800283a 	ret

00402630 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
  402630:	defff904 	addi	sp,sp,-28
  402634:	df000615 	stw	fp,24(sp)
  402638:	df000604 	addi	fp,sp,24
  40263c:	e13ffe15 	stw	r4,-8(fp)
  402640:	e17fff15 	stw	r5,-4(fp)
  402644:	e0bfff17 	ldw	r2,-4(fp)
  402648:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  40264c:	0005303a 	rdctl	r2,status
  402650:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  402654:	e0fffb17 	ldw	r3,-20(fp)
  402658:	00bfff84 	movi	r2,-2
  40265c:	1884703a 	and	r2,r3,r2
  402660:	1001703a 	wrctl	status,r2
  
  return context;
  402664:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  402668:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
  40266c:	e0bffa17 	ldw	r2,-24(fp)
  402670:	00c00044 	movi	r3,1
  402674:	1884983a 	sll	r2,r3,r2
  402678:	0084303a 	nor	r2,zero,r2
  40267c:	1007883a 	mov	r3,r2
  402680:	00801034 	movhi	r2,64
  402684:	1096c004 	addi	r2,r2,23296
  402688:	10800017 	ldw	r2,0(r2)
  40268c:	1886703a 	and	r3,r3,r2
  402690:	00801034 	movhi	r2,64
  402694:	1096c004 	addi	r2,r2,23296
  402698:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  40269c:	00801034 	movhi	r2,64
  4026a0:	1096c004 	addi	r2,r2,23296
  4026a4:	10800017 	ldw	r2,0(r2)
  4026a8:	100170fa 	wrctl	ienable,r2
  4026ac:	e0bffc17 	ldw	r2,-16(fp)
  4026b0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  4026b4:	e0bffd17 	ldw	r2,-12(fp)
  4026b8:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  4026bc:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
  4026c0:	0001883a 	nop
}
  4026c4:	e037883a 	mov	sp,fp
  4026c8:	df000017 	ldw	fp,0(sp)
  4026cc:	dec00104 	addi	sp,sp,4
  4026d0:	f800283a 	ret

004026d4 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
  4026d4:	defffc04 	addi	sp,sp,-16
  4026d8:	df000315 	stw	fp,12(sp)
  4026dc:	df000304 	addi	fp,sp,12
  4026e0:	e13ffe15 	stw	r4,-8(fp)
  4026e4:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
  4026e8:	000530fa 	rdctl	r2,ienable
  4026ec:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
  4026f0:	e0bfff17 	ldw	r2,-4(fp)
  4026f4:	00c00044 	movi	r3,1
  4026f8:	1884983a 	sll	r2,r3,r2
  4026fc:	1007883a 	mov	r3,r2
  402700:	e0bffd17 	ldw	r2,-12(fp)
  402704:	1884703a 	and	r2,r3,r2
  402708:	1004c03a 	cmpne	r2,r2,zero
  40270c:	10803fcc 	andi	r2,r2,255
}
  402710:	e037883a 	mov	sp,fp
  402714:	df000017 	ldw	fp,0(sp)
  402718:	dec00104 	addi	sp,sp,4
  40271c:	f800283a 	ret

00402720 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  402720:	defff504 	addi	sp,sp,-44
  402724:	dfc00a15 	stw	ra,40(sp)
  402728:	df000915 	stw	fp,36(sp)
  40272c:	df000904 	addi	fp,sp,36
  402730:	e13ffc15 	stw	r4,-16(fp)
  402734:	e17ffd15 	stw	r5,-12(fp)
  402738:	e1bffe15 	stw	r6,-8(fp)
  40273c:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
  402740:	00bffa84 	movi	r2,-22
  402744:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  402748:	e0bffd17 	ldw	r2,-12(fp)
  40274c:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
  402750:	e0bff817 	ldw	r2,-32(fp)
  402754:	10800808 	cmpgei	r2,r2,32
  402758:	1000271e 	bne	r2,zero,4027f8 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  40275c:	0005303a 	rdctl	r2,status
  402760:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  402764:	e0fffa17 	ldw	r3,-24(fp)
  402768:	00bfff84 	movi	r2,-2
  40276c:	1884703a 	and	r2,r3,r2
  402770:	1001703a 	wrctl	status,r2
  
  return context;
  402774:	e0bffa17 	ldw	r2,-24(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
  402778:	e0bff915 	stw	r2,-28(fp)

    alt_irq[id].handler = isr;
  40277c:	00801034 	movhi	r2,64
  402780:	1096c404 	addi	r2,r2,23312
  402784:	e0fff817 	ldw	r3,-32(fp)
  402788:	180690fa 	slli	r3,r3,3
  40278c:	10c5883a 	add	r2,r2,r3
  402790:	e0fffe17 	ldw	r3,-8(fp)
  402794:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
  402798:	00801034 	movhi	r2,64
  40279c:	1096c404 	addi	r2,r2,23312
  4027a0:	e0fff817 	ldw	r3,-32(fp)
  4027a4:	180690fa 	slli	r3,r3,3
  4027a8:	18c00104 	addi	r3,r3,4
  4027ac:	10c5883a 	add	r2,r2,r3
  4027b0:	e0ffff17 	ldw	r3,-4(fp)
  4027b4:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
  4027b8:	e0bffe17 	ldw	r2,-8(fp)
  4027bc:	10000526 	beq	r2,zero,4027d4 <alt_iic_isr_register+0xb4>
  4027c0:	e0bff817 	ldw	r2,-32(fp)
  4027c4:	e13ffc17 	ldw	r4,-16(fp)
  4027c8:	100b883a 	mov	r5,r2
  4027cc:	04025900 	call	402590 <alt_ic_irq_enable>
  4027d0:	00000406 	br	4027e4 <alt_iic_isr_register+0xc4>
  4027d4:	e0bff817 	ldw	r2,-32(fp)
  4027d8:	e13ffc17 	ldw	r4,-16(fp)
  4027dc:	100b883a 	mov	r5,r2
  4027e0:	04026300 	call	402630 <alt_ic_irq_disable>
  4027e4:	e0bff715 	stw	r2,-36(fp)
  4027e8:	e0bff917 	ldw	r2,-28(fp)
  4027ec:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  4027f0:	e0bffb17 	ldw	r2,-20(fp)
  4027f4:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
  4027f8:	e0bff717 	ldw	r2,-36(fp)
}
  4027fc:	e037883a 	mov	sp,fp
  402800:	dfc00117 	ldw	ra,4(sp)
  402804:	df000017 	ldw	fp,0(sp)
  402808:	dec00204 	addi	sp,sp,8
  40280c:	f800283a 	ret

00402810 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
  402810:	defffa04 	addi	sp,sp,-24
  402814:	df000515 	stw	fp,20(sp)
  402818:	df000504 	addi	fp,sp,20
  40281c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  402820:	0005303a 	rdctl	r2,status
  402824:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  402828:	e0fffc17 	ldw	r3,-16(fp)
  40282c:	00bfff84 	movi	r2,-2
  402830:	1884703a 	and	r2,r3,r2
  402834:	1001703a 	wrctl	status,r2
  
  return context;
  402838:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
  40283c:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
  402840:	e0bfff17 	ldw	r2,-4(fp)
  402844:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
  402848:	e0bffd17 	ldw	r2,-12(fp)
  40284c:	10800017 	ldw	r2,0(r2)
  402850:	e0fffd17 	ldw	r3,-12(fp)
  402854:	18c00117 	ldw	r3,4(r3)
  402858:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
  40285c:	e0bffd17 	ldw	r2,-12(fp)
  402860:	10800117 	ldw	r2,4(r2)
  402864:	e0fffd17 	ldw	r3,-12(fp)
  402868:	18c00017 	ldw	r3,0(r3)
  40286c:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
  402870:	e0bffd17 	ldw	r2,-12(fp)
  402874:	e0fffd17 	ldw	r3,-12(fp)
  402878:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
  40287c:	e0bffd17 	ldw	r2,-12(fp)
  402880:	e0fffd17 	ldw	r3,-12(fp)
  402884:	10c00015 	stw	r3,0(r2)
  402888:	e0bffb17 	ldw	r2,-20(fp)
  40288c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  402890:	e0bffe17 	ldw	r2,-8(fp)
  402894:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
  402898:	e037883a 	mov	sp,fp
  40289c:	df000017 	ldw	fp,0(sp)
  4028a0:	dec00104 	addi	sp,sp,4
  4028a4:	f800283a 	ret

004028a8 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
  4028a8:	defffb04 	addi	sp,sp,-20
  4028ac:	dfc00415 	stw	ra,16(sp)
  4028b0:	df000315 	stw	fp,12(sp)
  4028b4:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
  4028b8:	d0a00917 	ldw	r2,-32732(gp)
  4028bc:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
  4028c0:	d0a60717 	ldw	r2,-26596(gp)
  4028c4:	10800044 	addi	r2,r2,1
  4028c8:	d0a60715 	stw	r2,-26596(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  4028cc:	00002e06 	br	402988 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
  4028d0:	e0bffd17 	ldw	r2,-12(fp)
  4028d4:	10800017 	ldw	r2,0(r2)
  4028d8:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
  4028dc:	e0bffd17 	ldw	r2,-12(fp)
  4028e0:	10800403 	ldbu	r2,16(r2)
  4028e4:	10803fcc 	andi	r2,r2,255
  4028e8:	10000426 	beq	r2,zero,4028fc <alt_tick+0x54>
  4028ec:	d0a60717 	ldw	r2,-26596(gp)
  4028f0:	1000021e 	bne	r2,zero,4028fc <alt_tick+0x54>
    {
      alarm->rollover = 0;
  4028f4:	e0bffd17 	ldw	r2,-12(fp)
  4028f8:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
  4028fc:	e0bffd17 	ldw	r2,-12(fp)
  402900:	10800217 	ldw	r2,8(r2)
  402904:	d0e60717 	ldw	r3,-26596(gp)
  402908:	18801d36 	bltu	r3,r2,402980 <alt_tick+0xd8>
  40290c:	e0bffd17 	ldw	r2,-12(fp)
  402910:	10800403 	ldbu	r2,16(r2)
  402914:	10803fcc 	andi	r2,r2,255
  402918:	1000191e 	bne	r2,zero,402980 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
  40291c:	e0bffd17 	ldw	r2,-12(fp)
  402920:	10800317 	ldw	r2,12(r2)
  402924:	e0fffd17 	ldw	r3,-12(fp)
  402928:	18c00517 	ldw	r3,20(r3)
  40292c:	1809883a 	mov	r4,r3
  402930:	103ee83a 	callr	r2
  402934:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
  402938:	e0bfff17 	ldw	r2,-4(fp)
  40293c:	1000031e 	bne	r2,zero,40294c <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
  402940:	e13ffd17 	ldw	r4,-12(fp)
  402944:	04028100 	call	402810 <alt_alarm_stop>
  402948:	00000d06 	br	402980 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
  40294c:	e0bffd17 	ldw	r2,-12(fp)
  402950:	10c00217 	ldw	r3,8(r2)
  402954:	e0bfff17 	ldw	r2,-4(fp)
  402958:	1887883a 	add	r3,r3,r2
  40295c:	e0bffd17 	ldw	r2,-12(fp)
  402960:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
  402964:	e0bffd17 	ldw	r2,-12(fp)
  402968:	10c00217 	ldw	r3,8(r2)
  40296c:	d0a60717 	ldw	r2,-26596(gp)
  402970:	1880032e 	bgeu	r3,r2,402980 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
  402974:	e0bffd17 	ldw	r2,-12(fp)
  402978:	00c00044 	movi	r3,1
  40297c:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
  402980:	e0bffe17 	ldw	r2,-8(fp)
  402984:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  402988:	e0fffd17 	ldw	r3,-12(fp)
  40298c:	d0a00904 	addi	r2,gp,-32732
  402990:	18bfcf1e 	bne	r3,r2,4028d0 <__alt_mem_flash_tristate_controller_0+0xfd4028d0>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
  402994:	0001883a 	nop
}
  402998:	e037883a 	mov	sp,fp
  40299c:	dfc00117 	ldw	ra,4(sp)
  4029a0:	df000017 	ldw	fp,0(sp)
  4029a4:	dec00204 	addi	sp,sp,8
  4029a8:	f800283a 	ret

004029ac <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
  4029ac:	deffff04 	addi	sp,sp,-4
  4029b0:	df000015 	stw	fp,0(sp)
  4029b4:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
  4029b8:	000170fa 	wrctl	ienable,zero
}
  4029bc:	e037883a 	mov	sp,fp
  4029c0:	df000017 	ldw	fp,0(sp)
  4029c4:	dec00104 	addi	sp,sp,4
  4029c8:	f800283a 	ret

004029cc <udivmodsi4>:
  4029cc:	2900182e 	bgeu	r5,r4,402a30 <udivmodsi4+0x64>
  4029d0:	28001716 	blt	r5,zero,402a30 <udivmodsi4+0x64>
  4029d4:	00800804 	movi	r2,32
  4029d8:	00c00044 	movi	r3,1
  4029dc:	00000206 	br	4029e8 <udivmodsi4+0x1c>
  4029e0:	10001126 	beq	r2,zero,402a28 <udivmodsi4+0x5c>
  4029e4:	28000516 	blt	r5,zero,4029fc <udivmodsi4+0x30>
  4029e8:	294b883a 	add	r5,r5,r5
  4029ec:	10bfffc4 	addi	r2,r2,-1
  4029f0:	18c7883a 	add	r3,r3,r3
  4029f4:	293ffa36 	bltu	r5,r4,4029e0 <__alt_mem_flash_tristate_controller_0+0xfd4029e0>
  4029f8:	18000b26 	beq	r3,zero,402a28 <udivmodsi4+0x5c>
  4029fc:	0005883a 	mov	r2,zero
  402a00:	21400236 	bltu	r4,r5,402a0c <udivmodsi4+0x40>
  402a04:	2149c83a 	sub	r4,r4,r5
  402a08:	10c4b03a 	or	r2,r2,r3
  402a0c:	1806d07a 	srli	r3,r3,1
  402a10:	280ad07a 	srli	r5,r5,1
  402a14:	183ffa1e 	bne	r3,zero,402a00 <__alt_mem_flash_tristate_controller_0+0xfd402a00>
  402a18:	3000011e 	bne	r6,zero,402a20 <udivmodsi4+0x54>
  402a1c:	f800283a 	ret
  402a20:	2005883a 	mov	r2,r4
  402a24:	f800283a 	ret
  402a28:	0005883a 	mov	r2,zero
  402a2c:	003ffa06 	br	402a18 <__alt_mem_flash_tristate_controller_0+0xfd402a18>
  402a30:	00c00044 	movi	r3,1
  402a34:	003ff106 	br	4029fc <__alt_mem_flash_tristate_controller_0+0xfd4029fc>

00402a38 <__divsi3>:
  402a38:	defffe04 	addi	sp,sp,-8
  402a3c:	dfc00115 	stw	ra,4(sp)
  402a40:	dc000015 	stw	r16,0(sp)
  402a44:	20000b16 	blt	r4,zero,402a74 <__divsi3+0x3c>
  402a48:	0021883a 	mov	r16,zero
  402a4c:	28000c16 	blt	r5,zero,402a80 <__divsi3+0x48>
  402a50:	000d883a 	mov	r6,zero
  402a54:	04029cc0 	call	4029cc <udivmodsi4>
  402a58:	0407c83a 	sub	r3,zero,r16
  402a5c:	1884f03a 	xor	r2,r3,r2
  402a60:	1405883a 	add	r2,r2,r16
  402a64:	dfc00117 	ldw	ra,4(sp)
  402a68:	dc000017 	ldw	r16,0(sp)
  402a6c:	dec00204 	addi	sp,sp,8
  402a70:	f800283a 	ret
  402a74:	0109c83a 	sub	r4,zero,r4
  402a78:	04000044 	movi	r16,1
  402a7c:	283ff40e 	bge	r5,zero,402a50 <__alt_mem_flash_tristate_controller_0+0xfd402a50>
  402a80:	014bc83a 	sub	r5,zero,r5
  402a84:	8400005c 	xori	r16,r16,1
  402a88:	003ff106 	br	402a50 <__alt_mem_flash_tristate_controller_0+0xfd402a50>

00402a8c <__modsi3>:
  402a8c:	defffd04 	addi	sp,sp,-12
  402a90:	dfc00215 	stw	ra,8(sp)
  402a94:	dc400115 	stw	r17,4(sp)
  402a98:	dc000015 	stw	r16,0(sp)
  402a9c:	20000c16 	blt	r4,zero,402ad0 <__modsi3+0x44>
  402aa0:	0023883a 	mov	r17,zero
  402aa4:	0021883a 	mov	r16,zero
  402aa8:	28000d16 	blt	r5,zero,402ae0 <__modsi3+0x54>
  402aac:	01800044 	movi	r6,1
  402ab0:	04029cc0 	call	4029cc <udivmodsi4>
  402ab4:	1404f03a 	xor	r2,r2,r16
  402ab8:	8885883a 	add	r2,r17,r2
  402abc:	dfc00217 	ldw	ra,8(sp)
  402ac0:	dc400117 	ldw	r17,4(sp)
  402ac4:	dc000017 	ldw	r16,0(sp)
  402ac8:	dec00304 	addi	sp,sp,12
  402acc:	f800283a 	ret
  402ad0:	0109c83a 	sub	r4,zero,r4
  402ad4:	04400044 	movi	r17,1
  402ad8:	043fffc4 	movi	r16,-1
  402adc:	283ff30e 	bge	r5,zero,402aac <__alt_mem_flash_tristate_controller_0+0xfd402aac>
  402ae0:	014bc83a 	sub	r5,zero,r5
  402ae4:	003ff106 	br	402aac <__alt_mem_flash_tristate_controller_0+0xfd402aac>

00402ae8 <__udivsi3>:
  402ae8:	000d883a 	mov	r6,zero
  402aec:	04029cc1 	jmpi	4029cc <udivmodsi4>

00402af0 <__umodsi3>:
  402af0:	01800044 	movi	r6,1
  402af4:	04029cc1 	jmpi	4029cc <udivmodsi4>
