/****************************************************************************
 * IPG Photonics Corporation
 * COPYRIGHT (C) 2015 IPG Photonics Corporation ALL RIGHTS RESERVED
 * This program may not be reproduced, in whole or in part in any
 * form or any means whatsoever without the written permission of:
 *
 * IPG Photonics Corporation
 * 50 Old Webster Road
 * Oxford, MA 01540, USA
 ****************************************************************************/

/**
 * @file ipg_si5338.c
 * @author Dany Chamoun	(dchamoun@ipgphotonics.com)
 * @date Jan 26, 2015
 * @brief This file contains the functions needed to control/monitor/access a SI-5338 quad-clock generator.
 * @version 0.0.2
 *
 * @version 0.0.2: Added delay before reading/writing to the SiLAB
 *
 * The SI-5338 is an I2C programmable device. Normally, on startup, this device has to be configured to generate
 * the desired clocks for our system. For that reason, each SI-5338 instance has to be properly associated to a
 * configuration. The configuration is a list of 179 register/value pairs that is generated by the \a ClockBuilder
 * software.
 * <br>In case multiple devices are present on the same I2C bus. Having the same I2C address, an I2C multiplexer
 * or hub should be used to allow the host to select between the different available devices.
 * In this scenario, a \c select_i2c_channel_on_bus should be implemented to do the proper operations to select
 * a specific SI-5338 device.
 */

#include "../inc/ipg_si5338.h"

#define SI5338_SLOWDOWN   	0x60	//!<Constant value for clock slow down operation.
#define SI5338_SPEEDUP 		0x40	//!<Constant value for clock speed up operation.

#ifndef NULL
#define NULL	0
#endif

#define SI5338_LOCK_BIT		BIT4	//!<Constant representing the SI-5338 locked status. When set to 1 the device is locked to its reference clock.
#define MAX_RETRIES_COUNT 	2		//!<Constant value specifying how many times we should try to read if the silab is locked.


alt_u8 clk_speed_registers[4] = { 52, 63, 74, 85 }; //!<Array storing the registers used for clock speed control of the 4 clock outputs.
alt_u8 step_size_registers[4] = { 135, 164, 186, 208 }; //!<Array storing the registers used for PPM step size of the 4 clock outputs.

/*
 * local prototypes
 */
ret_code_t ipg_si5338_hardreset(si5338_device_t* _silab);

/**This function is used to write to a single register of a SI-5338 device.
 * If a \c select_i2c_channel_on_bus has been implemented, it calls it to make sure
 * the requested \a _silab is selected.
 * @param[in] _silab		instance of the SI-5338 device we want to write to
 * @param[in] si_register	the register offset we want to write to
 * @param[in] value			value to be written
 * @return				\c RET_SUCCESS on success
 * @since 0.0.1
 */
ret_code_t ipg_si5338_wr(si5338_device_t* _silab, alt_u8 si_register, alt_u8 value){
	ret_code_t result = RET_FAIL;
	alt_u8 txBuff[1] = { value };
	Delay_ms(1);
	select_i2c_channel_on_bus(_silab->i2c_dev.bus, _silab->i2c_dev.channel);
	Delay_ms(1);
	result = (!sls_write(_silab->i2c_dev.bus->fd, _silab->i2c_dev.address, (char *)txBuff, si_register, 1));
	return 	(result);
}

/**This function is used to read a single register from a SI-5338 device.
 * If a \c select_i2c_channel_on_bus has been implemented, it calls it to make sure
 * the requested \a _silab is selected.
 * @param[in] _silab		instance of the SI-5338 device we want to read from
 * @param[in] si_register	the register offset we want to read from
 * @param[out] value		pointer to where the read value will be stored
 * @return					\c RET_SUCCESS on success
 * @since 0.0.1
 */
ret_code_t ipg_si5338_rd( si5338_device_t* _silab, alt_u8 si_register, alt_u8 *value){
	ret_code_t ret = RET_FAIL;
	select_i2c_channel_on_bus(_silab->i2c_dev.bus, _silab->i2c_dev.channel);
	Delay_ms(1);
	ret = !sls_read(_silab->i2c_dev.bus->fd, _silab->i2c_dev.address, value, si_register, 1, 1);
	return 	(ret);
}

/**This function is used to change the speed on one clock output of the device.
 * If a \c select_i2c_channel_on_bus has been implemented, it calls it to make sure
 * the requested \a _silab is selected.
 * @param[in] _silab			instance of the SI-5338 device we want to control
 * @param[in] which_clk_output	which clock output we need to modify the speed
 * @param[in] operation			speed up or slow down the output's clock
 * 	@arg	SLOW_DOWN 	0
 * 	@arg	SPEED_UP 	1
 * @return					\c RET_SUCCESS on success
 * @since 0.0.1
 */
ret_code_t ipg_si5338_change_speed(si5338_device_t* _silab, alt_u8 which_clk_output, silab_clk_out_speed_t operation){
	alt_u8 txBuff[1];
	if(operation == SPEED_UP) txBuff[0] = SI5338_SPEEDUP;
	else if(operation == SLOW_DOWN) txBuff[0] = SI5338_SLOWDOWN;
	else return 	(RET_INVALID_PARAMS);
	return 	(ipg_si5338_wr(_silab, clk_speed_registers[which_clk_output], txBuff[0]));
}

/**This function is used to change the step size on one clock output of the device.
 *
 * @param[in] _silab  		silab to control
 * @param which_clk_output	which clock output to modify
 * @param size				desired step size
 * @return \c RET_SUCCESS on success
 * @since 0.0.2
 */
ret_code_t ipg_si5338_change_step(si5338_device_t* _silab, alt_u8 which_clk_output, alt_u16 size){
	alt_u8 txBuff = size >> 8;
	ret_code_t ret = RET_FAIL;
	ret = ipg_si5338_wr(_silab, step_size_registers[which_clk_output], txBuff);
	if(ret == RET_SUCCESS){
		txBuff = size & 0xFF;
		return ipg_si5338_wr(_silab, step_size_registers[which_clk_output]+1, txBuff);
	}
	return ret;
}

/**Recenters the clock output of a SILAB by removing all
 * steps increases/decreases that were executed previously.
 * @param[in] _silab	silab to control
 * @param[in] which_clk_output clock output to recenter
 * @return \c RET_SUCCESS on success
 * @since 0.0.2
 */
ret_code_t ipg_si5338_recenter(si5338_device_t* _silab, alt_u8 which_clk_output){
	alt_u8 txBuff = 0x10;
	return 	(ipg_si5338_wr(_silab, clk_speed_registers[which_clk_output], txBuff));
}

/**This function executes a hard reset of a SI-5338 device.
 *
 * @param[in] _silab 	instance of the SI-5338 device we want to control
 * @return				\c RET_SUCCESS on success
 * @since 0.0.1
 */
ret_code_t ipg_si5338_hardreset(si5338_device_t* _silab){
	return 	(ipg_si5338_wr(_silab, 0xF6, 3));
}

/**This function configures a SI-5338 device.
 * The configuration is the one that was bound to this device during initialization.
 * @param _silab	instance of the SI-5338 device we want to control
 * @return			\c RET_SUCCESS on success
 * @since 0.0.1
 */
ret_code_t ipg_si5338_config(si5338_device_t* _silab){
	int i = 0;
	select_i2c_channel_on_bus(_silab->i2c_dev.bus, _silab->i2c_dev.channel);

	ipg_si5338_hardreset(_silab);
	Delay_ms(50);

	for (i = 0; i < 179; i++){
		if(ipg_si5338_wr(_silab, _silab->configuration[i][0], _silab->configuration[i][1]) != RET_SUCCESS){
			Delay_ms(2);
			ipg_si5338_wr(_silab, _silab->configuration[i][0], _silab->configuration[i][1]);
		}
		Delay_ms(2);
	}
	return 	(RET_SUCCESS);
}

/**This function disables frequency step increment and decrement for a certain clock output of a SI-5338.
 *
 * @param[in] _silab pointer to the SI-5338 device that we need to access
 * @param[in] which_clk_output the SI-5338 clock output we need to control
 *  @arg CLK_0
 * 	@arg CLK_1
 * 	@arg CLK_2
 * 	@arg CLK_3
 * @return None
 * @since 0.0.1
 */
void ipg_si5338_disable_freq_inc_dec(si5338_device_t* _silab, alt_u8 which_clk_output){
	ipg_si5338_wr(_silab, clk_speed_registers[which_clk_output], 0x10);
}

/**This function enables frequency step increment and decrement for a certain clock output of a SI-5338.
 *
 * @param[in] _silab pointer to the SI-5338 device that we need to access
 * @param[in] which_clk_output the SI-5338 clock output we need to control
 * 	@arg CLK_0
 * 	@arg CLK_1
 * 	@arg CLK_2
 * 	@arg CLK_3
 * @return None
 * @since 0.0.1
 */
void ipg_si5338_enable_freq_inc_dec(si5338_device_t* _silab, alt_u8 which_clk_output){
	ipg_si5338_wr(_silab, clk_speed_registers[which_clk_output], 0);
}

/**This function checks if the SI-5338 is configured properly and is in lock.
 * It actually makes several reads to get rid of debounce errors.
 * @param[in] _silab instance of the silab we want to test
 * @return \c True if device is locked
 * @since 0.0.1
 */
ipg_bool_t ipg_si5338_locked(si5338_device_t* _silab){
	static alt_u8 retry = MAX_RETRIES_COUNT;
	ipg_bool_t first_hw_debounce = True;
	alt_u8 temp = 0;
	while (1){
		ipg_si5338_clr_pll_locked_bit(_silab);
		if (retry == 0){ // we retried several times and the PLL hasn't locked yet, return without doing it again
			retry = MAX_RETRIES_COUNT;
			return 			(False);
		}

		ipg_si5338_rd(_silab, 0xF7, &temp);
		if (BIT_IS_CLEAR(temp, SI5338_LOCK_BIT)){
			//first time in the debounce wait 20 ms and reread again
			if (first_hw_debounce && retry != 0){
				first_hw_debounce = False;
				Delay_ms(20);
				retry--;
			}else{
				retry = MAX_RETRIES_COUNT;
				return 				(True);
			}
		}else{
			Delay_ms(10);
			retry--;
		}
	}
	return 	(False);
}

/**This function clears the SI-5338's PLL lock status bit.
 *
 * @param[in] _silab instance of the silab we want to access
 * @return None
 * @since 0.0.1
 */
void ipg_si5338_clr_pll_locked_bit(si5338_device_t* _silab){
	ipg_si5338_wr(_silab, 0xF7, 0);
}

/**This helper function handles users' requests to write to a register to one of the SI-5338s.
 * It is dispatched from the I2C write handler (\a handle_i2c_wr()) with the SI-5338 as argument.
 * @param[in] _silab SILAB to write to
 * @param[in] offset offset of the register to write to
 * @param[in] value data to be written
 * @return \c RET_SUCCESS on success
 * @since 0.0.1
 */
ret_code_t handle_user_si5338_write(si5338_device_t* _silab, alt_u8 offset, alt_u8 value){
	return 	(ipg_si5338_wr(_silab, offset, value));
}

/**This helper function reads a register from one of the SILABs.
 * It is dispatched from the I2C read handler (\a handle_i2c_rd()) with the SILAB as argument.
 * @param[in] _silab SILAB to read from
 * @param[in] offset offset of the register to read from
 * @param[out] value pointer where the read data will be stored
 * @return \c RET_SUCCESS on success
 * @since 0.0.1
 */
ret_code_t handle_user_si5338_read(si5338_device_t* _silab, alt_u8 offset, alt_u8 *value){
	return 	(ipg_si5338_rd(_silab, offset, value));
}

/**This helper function configures one of the SI-5338s.
 * It is dispatched from the I2C config handler (\a handle_i2c_confgi()) with the SI-5338 as argument.
 * <br>Each SILAB has a configuration associated to it inside \a build_i2c_tree() function:
 * his is the configuration that will be used.
 * @param[in] _silab SILAB to configure
 * @return \c RET_SUCCESS on success
 * @since 0.0.1
 */
ret_code_t handle_user_si5338_config(si5338_device_t* _silab){
	return 	(ipg_si5338_config(_silab));
}
